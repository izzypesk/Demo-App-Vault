"use strict";
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Keystore
 * Storage for secrets and keys. When a user creates and encrypts Data Encryption Keys and Keypairs, they are stored in the Keystore. A user cannot access the Vault without first using the Keystore. In the current implementation the Keystore functionality is implemented by meeco-keystore.
 *
 * OpenAPI spec version: 2.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var url = require("url");
var portableFetch = require("portable-fetch");
var BASE_PATH = "https://localhost:4000".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
var BaseAPI = /** @class */ (function () {
    function BaseAPI(configuration, basePath, fetch) {
        if (basePath === void 0) { basePath = BASE_PATH; }
        if (fetch === void 0) { fetch = portableFetch; }
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
    return BaseAPI;
}());
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
var RequiredError = /** @class */ (function (_super) {
    __extends(RequiredError, _super);
    function RequiredError(field, msg) {
        var _this = _super.call(this, msg) || this;
        _this.field = field;
        return _this;
    }
    return RequiredError;
}(Error));
exports.RequiredError = RequiredError;
/**
 * AdmissionTokenApi - fetch parameter creator
 * @export
 */
exports.AdmissionTokenApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates an AdmissionToken, used as authentication for user creation.
         * @summary Creates an admission token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        admissionTokensPost: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/admission_tokens";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication providerApiKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an AdmissionToken, specified by its unique token value
         * @summary Returns an admission token
         * @param {string} token_value A token value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        admissionTokensTokenValueGet: function (token_value, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'token_value' is not null or undefined
            if (token_value === null || token_value === undefined) {
                throw new RequiredError('token_value', 'Required parameter token_value was null or undefined when calling admissionTokensTokenValueGet.');
            }
            var localVarPath = "/admission_tokens/{token_value}"
                .replace("{" + "token_value" + "}", encodeURIComponent(String(token_value)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication providerApiKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AdmissionTokenApi - functional programming interface
 * @export
 */
exports.AdmissionTokenApiFp = function (configuration) {
    return {
        /**
         * Creates an AdmissionToken, used as authentication for user creation.
         * @summary Creates an admission token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        admissionTokensPost: function (options) {
            var localVarFetchArgs = exports.AdmissionTokenApiFetchParamCreator(configuration).admissionTokensPost(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves an AdmissionToken, specified by its unique token value
         * @summary Returns an admission token
         * @param {string} token_value A token value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        admissionTokensTokenValueGet: function (token_value, options) {
            var localVarFetchArgs = exports.AdmissionTokenApiFetchParamCreator(configuration).admissionTokensTokenValueGet(token_value, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * AdmissionTokenApi - factory interface
 * @export
 */
exports.AdmissionTokenApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates an AdmissionToken, used as authentication for user creation.
         * @summary Creates an admission token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        admissionTokensPost: function (options) {
            return exports.AdmissionTokenApiFp(configuration).admissionTokensPost(options)(fetch, basePath);
        },
        /**
         * Retrieves an AdmissionToken, specified by its unique token value
         * @summary Returns an admission token
         * @param {string} token_value A token value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        admissionTokensTokenValueGet: function (token_value, options) {
            return exports.AdmissionTokenApiFp(configuration).admissionTokensTokenValueGet(token_value, options)(fetch, basePath);
        },
    };
};
/**
 * AdmissionTokenApi - object-oriented interface
 * @export
 * @class AdmissionTokenApi
 * @extends {BaseAPI}
 */
var AdmissionTokenApi = /** @class */ (function (_super) {
    __extends(AdmissionTokenApi, _super);
    function AdmissionTokenApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates an AdmissionToken, used as authentication for user creation.
     * @summary Creates an admission token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdmissionTokenApi
     */
    AdmissionTokenApi.prototype.admissionTokensPost = function (options) {
        return exports.AdmissionTokenApiFp(this.configuration).admissionTokensPost(options)(this.fetch, this.basePath);
    };
    /**
     * Retrieves an AdmissionToken, specified by its unique token value
     * @summary Returns an admission token
     * @param {string} token_value A token value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdmissionTokenApi
     */
    AdmissionTokenApi.prototype.admissionTokensTokenValueGet = function (token_value, options) {
        return exports.AdmissionTokenApiFp(this.configuration).admissionTokensTokenValueGet(token_value, options)(this.fetch, this.basePath);
    };
    return AdmissionTokenApi;
}(BaseAPI));
exports.AdmissionTokenApi = AdmissionTokenApi;
/**
 * DataEncryptionKeyApi - fetch parameter creator
 * @export
 */
exports.DataEncryptionKeyApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Deletes a data encryption key identified by its ID.
         * @summary Deletes a data encryption key
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataEncryptionKeysIdDelete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling dataEncryptionKeysIdDelete.');
            }
            var localVarPath = "/data_encryption_keys/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a data encryption key by its ID.The data encryption key is encrypted with the key encryption key (KEK) of the user. The format is the serialization format of the Cryppo library.
         * @summary Retrieves a data encryption key
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataEncryptionKeysIdGet: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling dataEncryptionKeysIdGet.');
            }
            var localVarPath = "/data_encryption_keys/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores a data encryption key encrypted with the key encryption key (KEK) of the user. The expected format is the serialization format of the Cryppo library.
         * @summary Stores a data encryption key
         * @param {PostDataEncryptionKeysRequest} [create_data_encryption_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataEncryptionKeysPost: function (create_data_encryption_params, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/data_encryption_keys";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostDataEncryptionKeysRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(create_data_encryption_params || {}) : (create_data_encryption_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DataEncryptionKeyApi - functional programming interface
 * @export
 */
exports.DataEncryptionKeyApiFp = function (configuration) {
    return {
        /**
         * Deletes a data encryption key identified by its ID.
         * @summary Deletes a data encryption key
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataEncryptionKeysIdDelete: function (id, options) {
            var localVarFetchArgs = exports.DataEncryptionKeyApiFetchParamCreator(configuration).dataEncryptionKeysIdDelete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a data encryption key by its ID.The data encryption key is encrypted with the key encryption key (KEK) of the user. The format is the serialization format of the Cryppo library.
         * @summary Retrieves a data encryption key
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataEncryptionKeysIdGet: function (id, options) {
            var localVarFetchArgs = exports.DataEncryptionKeyApiFetchParamCreator(configuration).dataEncryptionKeysIdGet(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Stores a data encryption key encrypted with the key encryption key (KEK) of the user. The expected format is the serialization format of the Cryppo library.
         * @summary Stores a data encryption key
         * @param {PostDataEncryptionKeysRequest} [create_data_encryption_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataEncryptionKeysPost: function (create_data_encryption_params, options) {
            var localVarFetchArgs = exports.DataEncryptionKeyApiFetchParamCreator(configuration).dataEncryptionKeysPost(create_data_encryption_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * DataEncryptionKeyApi - factory interface
 * @export
 */
exports.DataEncryptionKeyApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Deletes a data encryption key identified by its ID.
         * @summary Deletes a data encryption key
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataEncryptionKeysIdDelete: function (id, options) {
            return exports.DataEncryptionKeyApiFp(configuration).dataEncryptionKeysIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Retrieves a data encryption key by its ID.The data encryption key is encrypted with the key encryption key (KEK) of the user. The format is the serialization format of the Cryppo library.
         * @summary Retrieves a data encryption key
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataEncryptionKeysIdGet: function (id, options) {
            return exports.DataEncryptionKeyApiFp(configuration).dataEncryptionKeysIdGet(id, options)(fetch, basePath);
        },
        /**
         * Stores a data encryption key encrypted with the key encryption key (KEK) of the user. The expected format is the serialization format of the Cryppo library.
         * @summary Stores a data encryption key
         * @param {PostDataEncryptionKeysRequest} [create_data_encryption_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataEncryptionKeysPost: function (create_data_encryption_params, options) {
            return exports.DataEncryptionKeyApiFp(configuration).dataEncryptionKeysPost(create_data_encryption_params, options)(fetch, basePath);
        },
    };
};
/**
 * DataEncryptionKeyApi - object-oriented interface
 * @export
 * @class DataEncryptionKeyApi
 * @extends {BaseAPI}
 */
var DataEncryptionKeyApi = /** @class */ (function (_super) {
    __extends(DataEncryptionKeyApi, _super);
    function DataEncryptionKeyApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Deletes a data encryption key identified by its ID.
     * @summary Deletes a data encryption key
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEncryptionKeyApi
     */
    DataEncryptionKeyApi.prototype.dataEncryptionKeysIdDelete = function (id, options) {
        return exports.DataEncryptionKeyApiFp(this.configuration).dataEncryptionKeysIdDelete(id, options)(this.fetch, this.basePath);
    };
    /**
     * Retrieves a data encryption key by its ID.The data encryption key is encrypted with the key encryption key (KEK) of the user. The format is the serialization format of the Cryppo library.
     * @summary Retrieves a data encryption key
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEncryptionKeyApi
     */
    DataEncryptionKeyApi.prototype.dataEncryptionKeysIdGet = function (id, options) {
        return exports.DataEncryptionKeyApiFp(this.configuration).dataEncryptionKeysIdGet(id, options)(this.fetch, this.basePath);
    };
    /**
     * Stores a data encryption key encrypted with the key encryption key (KEK) of the user. The expected format is the serialization format of the Cryppo library.
     * @summary Stores a data encryption key
     * @param {PostDataEncryptionKeysRequest} [create_data_encryption_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEncryptionKeyApi
     */
    DataEncryptionKeyApi.prototype.dataEncryptionKeysPost = function (create_data_encryption_params, options) {
        return exports.DataEncryptionKeyApiFp(this.configuration).dataEncryptionKeysPost(create_data_encryption_params, options)(this.fetch, this.basePath);
    };
    return DataEncryptionKeyApi;
}(BaseAPI));
exports.DataEncryptionKeyApi = DataEncryptionKeyApi;
/**
 * EncryptionSpaceApi - fetch parameter creator
 * @export
 */
exports.EncryptionSpaceApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Deletes an encryption space
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encryptionSpacesIdDelete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling encryptionSpacesIdDelete.');
            }
            var localVarPath = "/encryption_spaces/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieves an encryption space
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encryptionSpacesIdGet: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling encryptionSpacesIdGet.');
            }
            var localVarPath = "/encryption_spaces/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates an encryption space
         * @param {PostEncryptionSpacesRequest} [create_encryption_space_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encryptionSpacesPost: function (create_encryption_space_params, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/encryption_spaces";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostEncryptionSpacesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(create_encryption_space_params || {}) : (create_encryption_space_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EncryptionSpaceApi - functional programming interface
 * @export
 */
exports.EncryptionSpaceApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Deletes an encryption space
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encryptionSpacesIdDelete: function (id, options) {
            var localVarFetchArgs = exports.EncryptionSpaceApiFetchParamCreator(configuration).encryptionSpacesIdDelete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Retrieves an encryption space
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encryptionSpacesIdGet: function (id, options) {
            var localVarFetchArgs = exports.EncryptionSpaceApiFetchParamCreator(configuration).encryptionSpacesIdGet(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Creates an encryption space
         * @param {PostEncryptionSpacesRequest} [create_encryption_space_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encryptionSpacesPost: function (create_encryption_space_params, options) {
            var localVarFetchArgs = exports.EncryptionSpaceApiFetchParamCreator(configuration).encryptionSpacesPost(create_encryption_space_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EncryptionSpaceApi - factory interface
 * @export
 */
exports.EncryptionSpaceApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Deletes an encryption space
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encryptionSpacesIdDelete: function (id, options) {
            return exports.EncryptionSpaceApiFp(configuration).encryptionSpacesIdDelete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Retrieves an encryption space
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encryptionSpacesIdGet: function (id, options) {
            return exports.EncryptionSpaceApiFp(configuration).encryptionSpacesIdGet(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates an encryption space
         * @param {PostEncryptionSpacesRequest} [create_encryption_space_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encryptionSpacesPost: function (create_encryption_space_params, options) {
            return exports.EncryptionSpaceApiFp(configuration).encryptionSpacesPost(create_encryption_space_params, options)(fetch, basePath);
        },
    };
};
/**
 * EncryptionSpaceApi - object-oriented interface
 * @export
 * @class EncryptionSpaceApi
 * @extends {BaseAPI}
 */
var EncryptionSpaceApi = /** @class */ (function (_super) {
    __extends(EncryptionSpaceApi, _super);
    function EncryptionSpaceApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Deletes an encryption space
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EncryptionSpaceApi
     */
    EncryptionSpaceApi.prototype.encryptionSpacesIdDelete = function (id, options) {
        return exports.EncryptionSpaceApiFp(this.configuration).encryptionSpacesIdDelete(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Retrieves an encryption space
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EncryptionSpaceApi
     */
    EncryptionSpaceApi.prototype.encryptionSpacesIdGet = function (id, options) {
        return exports.EncryptionSpaceApiFp(this.configuration).encryptionSpacesIdGet(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Creates an encryption space
     * @param {PostEncryptionSpacesRequest} [create_encryption_space_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EncryptionSpaceApi
     */
    EncryptionSpaceApi.prototype.encryptionSpacesPost = function (create_encryption_space_params, options) {
        return exports.EncryptionSpaceApiFp(this.configuration).encryptionSpacesPost(create_encryption_space_params, options)(this.fetch, this.basePath);
    };
    return EncryptionSpaceApi;
}(BaseAPI));
exports.EncryptionSpaceApi = EncryptionSpaceApi;
/**
 * ExternalAdmissionTokensApi - fetch parameter creator
 * @export
 */
exports.ExternalAdmissionTokensApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Retrieves admission tokens for the Vault and the Passphrase store. Admission tokens in Vault and the Passphrase store are required to create user accounts. Admission tokens can be created by the Keystore only on behalf of the user. Configuration variables that control interaction with mentioned services: `vault_present` and `passphrase_store_present`.
         * @summary Retrieve admission tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalAdmissionTokensGet: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/external_admission_tokens";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ExternalAdmissionTokensApi - functional programming interface
 * @export
 */
exports.ExternalAdmissionTokensApiFp = function (configuration) {
    return {
        /**
         * Retrieves admission tokens for the Vault and the Passphrase store. Admission tokens in Vault and the Passphrase store are required to create user accounts. Admission tokens can be created by the Keystore only on behalf of the user. Configuration variables that control interaction with mentioned services: `vault_present` and `passphrase_store_present`.
         * @summary Retrieve admission tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalAdmissionTokensGet: function (options) {
            var localVarFetchArgs = exports.ExternalAdmissionTokensApiFetchParamCreator(configuration).externalAdmissionTokensGet(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ExternalAdmissionTokensApi - factory interface
 * @export
 */
exports.ExternalAdmissionTokensApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Retrieves admission tokens for the Vault and the Passphrase store. Admission tokens in Vault and the Passphrase store are required to create user accounts. Admission tokens can be created by the Keystore only on behalf of the user. Configuration variables that control interaction with mentioned services: `vault_present` and `passphrase_store_present`.
         * @summary Retrieve admission tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalAdmissionTokensGet: function (options) {
            return exports.ExternalAdmissionTokensApiFp(configuration).externalAdmissionTokensGet(options)(fetch, basePath);
        },
    };
};
/**
 * ExternalAdmissionTokensApi - object-oriented interface
 * @export
 * @class ExternalAdmissionTokensApi
 * @extends {BaseAPI}
 */
var ExternalAdmissionTokensApi = /** @class */ (function (_super) {
    __extends(ExternalAdmissionTokensApi, _super);
    function ExternalAdmissionTokensApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves admission tokens for the Vault and the Passphrase store. Admission tokens in Vault and the Passphrase store are required to create user accounts. Admission tokens can be created by the Keystore only on behalf of the user. Configuration variables that control interaction with mentioned services: `vault_present` and `passphrase_store_present`.
     * @summary Retrieve admission tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAdmissionTokensApi
     */
    ExternalAdmissionTokensApi.prototype.externalAdmissionTokensGet = function (options) {
        return exports.ExternalAdmissionTokensApiFp(this.configuration).externalAdmissionTokensGet(options)(this.fetch, this.basePath);
    };
    return ExternalAdmissionTokensApi;
}(BaseAPI));
exports.ExternalAdmissionTokensApi = ExternalAdmissionTokensApi;
/**
 * HomeApi - fetch parameter creator
 * @export
 */
exports.HomeApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
         * @summary Gets recaptcha form  that can be used for getting a captcha_token for later use in the srp/username endpoint
         * @param {string} [redirect_url]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeCaptchaCallbackFormGet: function (redirect_url, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/home/captcha_callback_form";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (redirect_url !== undefined) {
                localVarQueryParameter['redirect_url'] = redirect_url;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
         * @summary Gets recaptcha form that can be used for getting a captcha_token for later use in the srp/username endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeCaptchaFormGet: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/home/captcha_form";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * HomeApi - functional programming interface
 * @export
 */
exports.HomeApiFp = function (configuration) {
    return {
        /**
         * Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
         * @summary Gets recaptcha form  that can be used for getting a captcha_token for later use in the srp/username endpoint
         * @param {string} [redirect_url]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeCaptchaCallbackFormGet: function (redirect_url, options) {
            var localVarFetchArgs = exports.HomeApiFetchParamCreator(configuration).homeCaptchaCallbackFormGet(redirect_url, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
         * @summary Gets recaptcha form that can be used for getting a captcha_token for later use in the srp/username endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeCaptchaFormGet: function (options) {
            var localVarFetchArgs = exports.HomeApiFetchParamCreator(configuration).homeCaptchaFormGet(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * HomeApi - factory interface
 * @export
 */
exports.HomeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
         * @summary Gets recaptcha form  that can be used for getting a captcha_token for later use in the srp/username endpoint
         * @param {string} [redirect_url]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeCaptchaCallbackFormGet: function (redirect_url, options) {
            return exports.HomeApiFp(configuration).homeCaptchaCallbackFormGet(redirect_url, options)(fetch, basePath);
        },
        /**
         * Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
         * @summary Gets recaptcha form that can be used for getting a captcha_token for later use in the srp/username endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeCaptchaFormGet: function (options) {
            return exports.HomeApiFp(configuration).homeCaptchaFormGet(options)(fetch, basePath);
        },
    };
};
/**
 * HomeApi - object-oriented interface
 * @export
 * @class HomeApi
 * @extends {BaseAPI}
 */
var HomeApi = /** @class */ (function (_super) {
    __extends(HomeApi, _super);
    function HomeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
     * @summary Gets recaptcha form  that can be used for getting a captcha_token for later use in the srp/username endpoint
     * @param {string} [redirect_url]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HomeApi
     */
    HomeApi.prototype.homeCaptchaCallbackFormGet = function (redirect_url, options) {
        return exports.HomeApiFp(this.configuration).homeCaptchaCallbackFormGet(redirect_url, options)(this.fetch, this.basePath);
    };
    /**
     * Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
     * @summary Gets recaptcha form that can be used for getting a captcha_token for later use in the srp/username endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HomeApi
     */
    HomeApi.prototype.homeCaptchaFormGet = function (options) {
        return exports.HomeApiFp(this.configuration).homeCaptchaFormGet(options)(this.fetch, this.basePath);
    };
    return HomeApi;
}(BaseAPI));
exports.HomeApi = HomeApi;
/**
 * ImportUserApi - fetch parameter creator
 * @export
 */
exports.ImportUserApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Creates a new user key store user and imports the keys
         * @param {PostImportUserRequest} [import_user_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserPost: function (import_user_params, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/import_user";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication providerApiKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostImportUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(import_user_params || {}) : (import_user_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ImportUserApi - functional programming interface
 * @export
 */
exports.ImportUserApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Creates a new user key store user and imports the keys
         * @param {PostImportUserRequest} [import_user_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserPost: function (import_user_params, options) {
            var localVarFetchArgs = exports.ImportUserApiFetchParamCreator(configuration).importUserPost(import_user_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ImportUserApi - factory interface
 * @export
 */
exports.ImportUserApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Creates a new user key store user and imports the keys
         * @param {PostImportUserRequest} [import_user_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserPost: function (import_user_params, options) {
            return exports.ImportUserApiFp(configuration).importUserPost(import_user_params, options)(fetch, basePath);
        },
    };
};
/**
 * ImportUserApi - object-oriented interface
 * @export
 * @class ImportUserApi
 * @extends {BaseAPI}
 */
var ImportUserApi = /** @class */ (function (_super) {
    __extends(ImportUserApi, _super);
    function ImportUserApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Creates a new user key store user and imports the keys
     * @param {PostImportUserRequest} [import_user_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportUserApi
     */
    ImportUserApi.prototype.importUserPost = function (import_user_params, options) {
        return exports.ImportUserApiFp(this.configuration).importUserPost(import_user_params, options)(this.fetch, this.basePath);
    };
    return ImportUserApi;
}(BaseAPI));
exports.ImportUserApi = ImportUserApi;
/**
 * KeyEncryptionKeyApi - fetch parameter creator
 * @export
 */
exports.KeyEncryptionKeyApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a key encryption key (KEK) encrypted with the passphrase derived key of the user. The format is the serialization format of the Cryppo library.
         * @summary Retrieves a key encryption key  (KEK)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyEncryptionKeyGet: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/key_encryption_key";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores a key encryption key (KEK) encrypted with the passphrase derived key of the user. The expected format is the serialization format of the Cryppo library.
         * @summary Stores a key encryption key (KEK)
         * @param {PostKeyEncryptionKeyRequest} [create_key_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyEncryptionKeyPost: function (create_key_params, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/key_encryption_key";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostKeyEncryptionKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(create_key_params || {}) : (create_key_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * KeyEncryptionKeyApi - functional programming interface
 * @export
 */
exports.KeyEncryptionKeyApiFp = function (configuration) {
    return {
        /**
         * Returns a key encryption key (KEK) encrypted with the passphrase derived key of the user. The format is the serialization format of the Cryppo library.
         * @summary Retrieves a key encryption key  (KEK)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyEncryptionKeyGet: function (options) {
            var localVarFetchArgs = exports.KeyEncryptionKeyApiFetchParamCreator(configuration).keyEncryptionKeyGet(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Stores a key encryption key (KEK) encrypted with the passphrase derived key of the user. The expected format is the serialization format of the Cryppo library.
         * @summary Stores a key encryption key (KEK)
         * @param {PostKeyEncryptionKeyRequest} [create_key_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyEncryptionKeyPost: function (create_key_params, options) {
            var localVarFetchArgs = exports.KeyEncryptionKeyApiFetchParamCreator(configuration).keyEncryptionKeyPost(create_key_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * KeyEncryptionKeyApi - factory interface
 * @export
 */
exports.KeyEncryptionKeyApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Returns a key encryption key (KEK) encrypted with the passphrase derived key of the user. The format is the serialization format of the Cryppo library.
         * @summary Retrieves a key encryption key  (KEK)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyEncryptionKeyGet: function (options) {
            return exports.KeyEncryptionKeyApiFp(configuration).keyEncryptionKeyGet(options)(fetch, basePath);
        },
        /**
         * Stores a key encryption key (KEK) encrypted with the passphrase derived key of the user. The expected format is the serialization format of the Cryppo library.
         * @summary Stores a key encryption key (KEK)
         * @param {PostKeyEncryptionKeyRequest} [create_key_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyEncryptionKeyPost: function (create_key_params, options) {
            return exports.KeyEncryptionKeyApiFp(configuration).keyEncryptionKeyPost(create_key_params, options)(fetch, basePath);
        },
    };
};
/**
 * KeyEncryptionKeyApi - object-oriented interface
 * @export
 * @class KeyEncryptionKeyApi
 * @extends {BaseAPI}
 */
var KeyEncryptionKeyApi = /** @class */ (function (_super) {
    __extends(KeyEncryptionKeyApi, _super);
    function KeyEncryptionKeyApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns a key encryption key (KEK) encrypted with the passphrase derived key of the user. The format is the serialization format of the Cryppo library.
     * @summary Retrieves a key encryption key  (KEK)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyEncryptionKeyApi
     */
    KeyEncryptionKeyApi.prototype.keyEncryptionKeyGet = function (options) {
        return exports.KeyEncryptionKeyApiFp(this.configuration).keyEncryptionKeyGet(options)(this.fetch, this.basePath);
    };
    /**
     * Stores a key encryption key (KEK) encrypted with the passphrase derived key of the user. The expected format is the serialization format of the Cryppo library.
     * @summary Stores a key encryption key (KEK)
     * @param {PostKeyEncryptionKeyRequest} [create_key_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyEncryptionKeyApi
     */
    KeyEncryptionKeyApi.prototype.keyEncryptionKeyPost = function (create_key_params, options) {
        return exports.KeyEncryptionKeyApiFp(this.configuration).keyEncryptionKeyPost(create_key_params, options)(this.fetch, this.basePath);
    };
    return KeyEncryptionKeyApi;
}(BaseAPI));
exports.KeyEncryptionKeyApi = KeyEncryptionKeyApi;
/**
 * KeypairApi - fetch parameter creator
 * @export
 */
exports.KeypairApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Retrieves a KeyPair specified by `external_id` (eg the `id` for a Connection, if the KeyPair was created for that purpose).
         * @summary Retrieves a keypair by external id
         * @param {string} external_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keypairsExternalIdExternalIdGet: function (external_id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'external_id' is not null or undefined
            if (external_id === null || external_id === undefined) {
                throw new RequiredError('external_id', 'Required parameter external_id was null or undefined when calling keypairsExternalIdExternalIdGet.');
            }
            var localVarPath = "/keypairs/external_id/{external_id}"
                .replace("{" + "external_id" + "}", encodeURIComponent(String(external_id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a keypair identified by its ID.
         * @summary Deletes a keypair
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keypairsIdDelete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling keypairsIdDelete.');
            }
            var localVarPath = "/keypairs/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a keypair identified by its ID. The keypair encrypted with the key encryption key (KEK) of the user (field `encrypted_serialized_key`). The format is the serialization format of the Cryppo library. The public key is also served unencrypted as a PEM
         * @summary Retrieves a keypair
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keypairsIdGet: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling keypairsIdGet.');
            }
            var localVarPath = "/keypairs/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates fields for KeyPair specified by id with new values if provided in params.
         * @summary Updates a keypair
         * @param {string} id
         * @param {PutKeypairsRequest} [update_keypair_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keypairsIdPatch: function (id, update_keypair_params, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling keypairsIdPatch.');
            }
            var localVarPath = "/keypairs/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PutKeypairsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(update_keypair_params || {}) : (update_keypair_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores a keypair. The keypair encrypted with the key encryption key (KEK) of the user (field `encrypted_serialized_key`). The format is the serialization format of the Cryppo library. Also stores the public key unencrypted as a PEM. Each keypair can be tagged by a list of tags which make is possible for the client to differentiate between various keypairs.
         * @summary Stores a keypair
         * @param {PostKeypairsRequest} [create_keypair_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keypairsPost: function (create_keypair_params, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/keypairs";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostKeypairsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(create_keypair_params || {}) : (create_keypair_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * KeypairApi - functional programming interface
 * @export
 */
exports.KeypairApiFp = function (configuration) {
    return {
        /**
         * Retrieves a KeyPair specified by `external_id` (eg the `id` for a Connection, if the KeyPair was created for that purpose).
         * @summary Retrieves a keypair by external id
         * @param {string} external_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keypairsExternalIdExternalIdGet: function (external_id, options) {
            var localVarFetchArgs = exports.KeypairApiFetchParamCreator(configuration).keypairsExternalIdExternalIdGet(external_id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a keypair identified by its ID.
         * @summary Deletes a keypair
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keypairsIdDelete: function (id, options) {
            var localVarFetchArgs = exports.KeypairApiFetchParamCreator(configuration).keypairsIdDelete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a keypair identified by its ID. The keypair encrypted with the key encryption key (KEK) of the user (field `encrypted_serialized_key`). The format is the serialization format of the Cryppo library. The public key is also served unencrypted as a PEM
         * @summary Retrieves a keypair
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keypairsIdGet: function (id, options) {
            var localVarFetchArgs = exports.KeypairApiFetchParamCreator(configuration).keypairsIdGet(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates fields for KeyPair specified by id with new values if provided in params.
         * @summary Updates a keypair
         * @param {string} id
         * @param {PutKeypairsRequest} [update_keypair_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keypairsIdPatch: function (id, update_keypair_params, options) {
            var localVarFetchArgs = exports.KeypairApiFetchParamCreator(configuration).keypairsIdPatch(id, update_keypair_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Stores a keypair. The keypair encrypted with the key encryption key (KEK) of the user (field `encrypted_serialized_key`). The format is the serialization format of the Cryppo library. Also stores the public key unencrypted as a PEM. Each keypair can be tagged by a list of tags which make is possible for the client to differentiate between various keypairs.
         * @summary Stores a keypair
         * @param {PostKeypairsRequest} [create_keypair_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keypairsPost: function (create_keypair_params, options) {
            var localVarFetchArgs = exports.KeypairApiFetchParamCreator(configuration).keypairsPost(create_keypair_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * KeypairApi - factory interface
 * @export
 */
exports.KeypairApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Retrieves a KeyPair specified by `external_id` (eg the `id` for a Connection, if the KeyPair was created for that purpose).
         * @summary Retrieves a keypair by external id
         * @param {string} external_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keypairsExternalIdExternalIdGet: function (external_id, options) {
            return exports.KeypairApiFp(configuration).keypairsExternalIdExternalIdGet(external_id, options)(fetch, basePath);
        },
        /**
         * Deletes a keypair identified by its ID.
         * @summary Deletes a keypair
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keypairsIdDelete: function (id, options) {
            return exports.KeypairApiFp(configuration).keypairsIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Retrieves a keypair identified by its ID. The keypair encrypted with the key encryption key (KEK) of the user (field `encrypted_serialized_key`). The format is the serialization format of the Cryppo library. The public key is also served unencrypted as a PEM
         * @summary Retrieves a keypair
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keypairsIdGet: function (id, options) {
            return exports.KeypairApiFp(configuration).keypairsIdGet(id, options)(fetch, basePath);
        },
        /**
         * Updates fields for KeyPair specified by id with new values if provided in params.
         * @summary Updates a keypair
         * @param {string} id
         * @param {PutKeypairsRequest} [update_keypair_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keypairsIdPatch: function (id, update_keypair_params, options) {
            return exports.KeypairApiFp(configuration).keypairsIdPatch(id, update_keypair_params, options)(fetch, basePath);
        },
        /**
         * Stores a keypair. The keypair encrypted with the key encryption key (KEK) of the user (field `encrypted_serialized_key`). The format is the serialization format of the Cryppo library. Also stores the public key unencrypted as a PEM. Each keypair can be tagged by a list of tags which make is possible for the client to differentiate between various keypairs.
         * @summary Stores a keypair
         * @param {PostKeypairsRequest} [create_keypair_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keypairsPost: function (create_keypair_params, options) {
            return exports.KeypairApiFp(configuration).keypairsPost(create_keypair_params, options)(fetch, basePath);
        },
    };
};
/**
 * KeypairApi - object-oriented interface
 * @export
 * @class KeypairApi
 * @extends {BaseAPI}
 */
var KeypairApi = /** @class */ (function (_super) {
    __extends(KeypairApi, _super);
    function KeypairApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a KeyPair specified by `external_id` (eg the `id` for a Connection, if the KeyPair was created for that purpose).
     * @summary Retrieves a keypair by external id
     * @param {string} external_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeypairApi
     */
    KeypairApi.prototype.keypairsExternalIdExternalIdGet = function (external_id, options) {
        return exports.KeypairApiFp(this.configuration).keypairsExternalIdExternalIdGet(external_id, options)(this.fetch, this.basePath);
    };
    /**
     * Deletes a keypair identified by its ID.
     * @summary Deletes a keypair
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeypairApi
     */
    KeypairApi.prototype.keypairsIdDelete = function (id, options) {
        return exports.KeypairApiFp(this.configuration).keypairsIdDelete(id, options)(this.fetch, this.basePath);
    };
    /**
     * Retrieves a keypair identified by its ID. The keypair encrypted with the key encryption key (KEK) of the user (field `encrypted_serialized_key`). The format is the serialization format of the Cryppo library. The public key is also served unencrypted as a PEM
     * @summary Retrieves a keypair
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeypairApi
     */
    KeypairApi.prototype.keypairsIdGet = function (id, options) {
        return exports.KeypairApiFp(this.configuration).keypairsIdGet(id, options)(this.fetch, this.basePath);
    };
    /**
     * Updates fields for KeyPair specified by id with new values if provided in params.
     * @summary Updates a keypair
     * @param {string} id
     * @param {PutKeypairsRequest} [update_keypair_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeypairApi
     */
    KeypairApi.prototype.keypairsIdPatch = function (id, update_keypair_params, options) {
        return exports.KeypairApiFp(this.configuration).keypairsIdPatch(id, update_keypair_params, options)(this.fetch, this.basePath);
    };
    /**
     * Stores a keypair. The keypair encrypted with the key encryption key (KEK) of the user (field `encrypted_serialized_key`). The format is the serialization format of the Cryppo library. Also stores the public key unencrypted as a PEM. Each keypair can be tagged by a list of tags which make is possible for the client to differentiate between various keypairs.
     * @summary Stores a keypair
     * @param {PostKeypairsRequest} [create_keypair_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeypairApi
     */
    KeypairApi.prototype.keypairsPost = function (create_keypair_params, options) {
        return exports.KeypairApiFp(this.configuration).keypairsPost(create_keypair_params, options)(this.fetch, this.basePath);
    };
    return KeypairApi;
}(BaseAPI));
exports.KeypairApi = KeypairApi;
/**
 * PassphraseDerivationArtefactApi - fetch parameter creator
 * @export
 */
exports.PassphraseDerivationArtefactApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returnes passphrase derivation artefacts which were used for generation of the passphrase derived key.The format is as a JSON string encoded as Base64 (urlsafe).
         * @summary Retrieves the passphrase derivation artefact for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passphraseDerivationArtefactGet: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/passphrase_derivation_artefact";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Passphrase derivation artefacts used for generation of the passphrase derived key are expected to be sent as a JSON string encoded as Base64 (urlsafe) a field of the payload to this endpoint.
         * @summary Stores passphrase derivation artefacts
         * @param {PostPassphraseDerivationArtefactRequest} [create_passphrase_artefact_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passphraseDerivationArtefactPost: function (create_passphrase_artefact_params, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/passphrase_derivation_artefact";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostPassphraseDerivationArtefactRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(create_passphrase_artefact_params || {}) : (create_passphrase_artefact_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PassphraseDerivationArtefactApi - functional programming interface
 * @export
 */
exports.PassphraseDerivationArtefactApiFp = function (configuration) {
    return {
        /**
         * Returnes passphrase derivation artefacts which were used for generation of the passphrase derived key.The format is as a JSON string encoded as Base64 (urlsafe).
         * @summary Retrieves the passphrase derivation artefact for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passphraseDerivationArtefactGet: function (options) {
            var localVarFetchArgs = exports.PassphraseDerivationArtefactApiFetchParamCreator(configuration).passphraseDerivationArtefactGet(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Passphrase derivation artefacts used for generation of the passphrase derived key are expected to be sent as a JSON string encoded as Base64 (urlsafe) a field of the payload to this endpoint.
         * @summary Stores passphrase derivation artefacts
         * @param {PostPassphraseDerivationArtefactRequest} [create_passphrase_artefact_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passphraseDerivationArtefactPost: function (create_passphrase_artefact_params, options) {
            var localVarFetchArgs = exports.PassphraseDerivationArtefactApiFetchParamCreator(configuration).passphraseDerivationArtefactPost(create_passphrase_artefact_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * PassphraseDerivationArtefactApi - factory interface
 * @export
 */
exports.PassphraseDerivationArtefactApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Returnes passphrase derivation artefacts which were used for generation of the passphrase derived key.The format is as a JSON string encoded as Base64 (urlsafe).
         * @summary Retrieves the passphrase derivation artefact for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passphraseDerivationArtefactGet: function (options) {
            return exports.PassphraseDerivationArtefactApiFp(configuration).passphraseDerivationArtefactGet(options)(fetch, basePath);
        },
        /**
         * Passphrase derivation artefacts used for generation of the passphrase derived key are expected to be sent as a JSON string encoded as Base64 (urlsafe) a field of the payload to this endpoint.
         * @summary Stores passphrase derivation artefacts
         * @param {PostPassphraseDerivationArtefactRequest} [create_passphrase_artefact_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passphraseDerivationArtefactPost: function (create_passphrase_artefact_params, options) {
            return exports.PassphraseDerivationArtefactApiFp(configuration).passphraseDerivationArtefactPost(create_passphrase_artefact_params, options)(fetch, basePath);
        },
    };
};
/**
 * PassphraseDerivationArtefactApi - object-oriented interface
 * @export
 * @class PassphraseDerivationArtefactApi
 * @extends {BaseAPI}
 */
var PassphraseDerivationArtefactApi = /** @class */ (function (_super) {
    __extends(PassphraseDerivationArtefactApi, _super);
    function PassphraseDerivationArtefactApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returnes passphrase derivation artefacts which were used for generation of the passphrase derived key.The format is as a JSON string encoded as Base64 (urlsafe).
     * @summary Retrieves the passphrase derivation artefact for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassphraseDerivationArtefactApi
     */
    PassphraseDerivationArtefactApi.prototype.passphraseDerivationArtefactGet = function (options) {
        return exports.PassphraseDerivationArtefactApiFp(this.configuration).passphraseDerivationArtefactGet(options)(this.fetch, this.basePath);
    };
    /**
     * Passphrase derivation artefacts used for generation of the passphrase derived key are expected to be sent as a JSON string encoded as Base64 (urlsafe) a field of the payload to this endpoint.
     * @summary Stores passphrase derivation artefacts
     * @param {PostPassphraseDerivationArtefactRequest} [create_passphrase_artefact_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassphraseDerivationArtefactApi
     */
    PassphraseDerivationArtefactApi.prototype.passphraseDerivationArtefactPost = function (create_passphrase_artefact_params, options) {
        return exports.PassphraseDerivationArtefactApiFp(this.configuration).passphraseDerivationArtefactPost(create_passphrase_artefact_params, options)(this.fetch, this.basePath);
    };
    return PassphraseDerivationArtefactApi;
}(BaseAPI));
exports.PassphraseDerivationArtefactApi = PassphraseDerivationArtefactApi;
/**
 * SessionApi - fetch parameter creator
 * @export
 */
exports.SessionApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Deletes either (1) all user sessions (that is, access tokens), (2) or all user sessions except for the session under which the current call is being executed.
         * @summary Deletes all user sessions
         * @param {string} [delete_all_sessions_params] if present, the current session will not be deleted. If absent, all current session will be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionAllDelete: function (delete_all_sessions_params, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/session/all";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (delete_all_sessions_params !== undefined) {
                localVarQueryParameter['delete_all_sessions_params'] = delete_all_sessions_params;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log out, deleting current Session.
         * @summary Deletes a session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionDelete: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/session";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log in with username and passphrase, creating a Session
         * @summary Creates a session
         * @param {PostSessionRequest} [create_session_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPost: function (create_session_params, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/session";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostSessionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(create_session_params || {}) : (create_session_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A call to log in and obtain a session authentication string in the flowwith an external party. `login_key` is an identification token which will be sent to the external party for user verification.This call must be preceded by the external party calling `/admin/users` and creating a user record.
         * @summary Creates a session with a login key of the external party
         * @param {PostSessionWithLoginKeyRequest} [create_session_with_login_key_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionWithLoginKeyPost: function (create_session_with_login_key_params, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/session/with_login_key";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostSessionWithLoginKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(create_session_with_login_key_params || {}) : (create_session_with_login_key_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a session using SRP (Secure Remote Password) authentication
         * @summary Creates a session with SRP authentication
         * @param {PostSrpSessionRequest} [user_param]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        srpSessionPost: function (user_param, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/srp/session";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostSrpSessionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(user_param || {}) : (user_param || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SessionApi - functional programming interface
 * @export
 */
exports.SessionApiFp = function (configuration) {
    return {
        /**
         * Deletes either (1) all user sessions (that is, access tokens), (2) or all user sessions except for the session under which the current call is being executed.
         * @summary Deletes all user sessions
         * @param {string} [delete_all_sessions_params] if present, the current session will not be deleted. If absent, all current session will be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionAllDelete: function (delete_all_sessions_params, options) {
            var localVarFetchArgs = exports.SessionApiFetchParamCreator(configuration).sessionAllDelete(delete_all_sessions_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Log out, deleting current Session.
         * @summary Deletes a session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionDelete: function (options) {
            var localVarFetchArgs = exports.SessionApiFetchParamCreator(configuration).sessionDelete(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Log in with username and passphrase, creating a Session
         * @summary Creates a session
         * @param {PostSessionRequest} [create_session_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPost: function (create_session_params, options) {
            var localVarFetchArgs = exports.SessionApiFetchParamCreator(configuration).sessionPost(create_session_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A call to log in and obtain a session authentication string in the flowwith an external party. `login_key` is an identification token which will be sent to the external party for user verification.This call must be preceded by the external party calling `/admin/users` and creating a user record.
         * @summary Creates a session with a login key of the external party
         * @param {PostSessionWithLoginKeyRequest} [create_session_with_login_key_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionWithLoginKeyPost: function (create_session_with_login_key_params, options) {
            var localVarFetchArgs = exports.SessionApiFetchParamCreator(configuration).sessionWithLoginKeyPost(create_session_with_login_key_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a session using SRP (Secure Remote Password) authentication
         * @summary Creates a session with SRP authentication
         * @param {PostSrpSessionRequest} [user_param]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        srpSessionPost: function (user_param, options) {
            var localVarFetchArgs = exports.SessionApiFetchParamCreator(configuration).srpSessionPost(user_param, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * SessionApi - factory interface
 * @export
 */
exports.SessionApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Deletes either (1) all user sessions (that is, access tokens), (2) or all user sessions except for the session under which the current call is being executed.
         * @summary Deletes all user sessions
         * @param {string} [delete_all_sessions_params] if present, the current session will not be deleted. If absent, all current session will be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionAllDelete: function (delete_all_sessions_params, options) {
            return exports.SessionApiFp(configuration).sessionAllDelete(delete_all_sessions_params, options)(fetch, basePath);
        },
        /**
         * Log out, deleting current Session.
         * @summary Deletes a session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionDelete: function (options) {
            return exports.SessionApiFp(configuration).sessionDelete(options)(fetch, basePath);
        },
        /**
         * Log in with username and passphrase, creating a Session
         * @summary Creates a session
         * @param {PostSessionRequest} [create_session_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPost: function (create_session_params, options) {
            return exports.SessionApiFp(configuration).sessionPost(create_session_params, options)(fetch, basePath);
        },
        /**
         * A call to log in and obtain a session authentication string in the flowwith an external party. `login_key` is an identification token which will be sent to the external party for user verification.This call must be preceded by the external party calling `/admin/users` and creating a user record.
         * @summary Creates a session with a login key of the external party
         * @param {PostSessionWithLoginKeyRequest} [create_session_with_login_key_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionWithLoginKeyPost: function (create_session_with_login_key_params, options) {
            return exports.SessionApiFp(configuration).sessionWithLoginKeyPost(create_session_with_login_key_params, options)(fetch, basePath);
        },
        /**
         * Creates a session using SRP (Secure Remote Password) authentication
         * @summary Creates a session with SRP authentication
         * @param {PostSrpSessionRequest} [user_param]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        srpSessionPost: function (user_param, options) {
            return exports.SessionApiFp(configuration).srpSessionPost(user_param, options)(fetch, basePath);
        },
    };
};
/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
var SessionApi = /** @class */ (function (_super) {
    __extends(SessionApi, _super);
    function SessionApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Deletes either (1) all user sessions (that is, access tokens), (2) or all user sessions except for the session under which the current call is being executed.
     * @summary Deletes all user sessions
     * @param {string} [delete_all_sessions_params] if present, the current session will not be deleted. If absent, all current session will be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    SessionApi.prototype.sessionAllDelete = function (delete_all_sessions_params, options) {
        return exports.SessionApiFp(this.configuration).sessionAllDelete(delete_all_sessions_params, options)(this.fetch, this.basePath);
    };
    /**
     * Log out, deleting current Session.
     * @summary Deletes a session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    SessionApi.prototype.sessionDelete = function (options) {
        return exports.SessionApiFp(this.configuration).sessionDelete(options)(this.fetch, this.basePath);
    };
    /**
     * Log in with username and passphrase, creating a Session
     * @summary Creates a session
     * @param {PostSessionRequest} [create_session_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    SessionApi.prototype.sessionPost = function (create_session_params, options) {
        return exports.SessionApiFp(this.configuration).sessionPost(create_session_params, options)(this.fetch, this.basePath);
    };
    /**
     * A call to log in and obtain a session authentication string in the flowwith an external party. `login_key` is an identification token which will be sent to the external party for user verification.This call must be preceded by the external party calling `/admin/users` and creating a user record.
     * @summary Creates a session with a login key of the external party
     * @param {PostSessionWithLoginKeyRequest} [create_session_with_login_key_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    SessionApi.prototype.sessionWithLoginKeyPost = function (create_session_with_login_key_params, options) {
        return exports.SessionApiFp(this.configuration).sessionWithLoginKeyPost(create_session_with_login_key_params, options)(this.fetch, this.basePath);
    };
    /**
     * Creates a session using SRP (Secure Remote Password) authentication
     * @summary Creates a session with SRP authentication
     * @param {PostSrpSessionRequest} [user_param]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    SessionApi.prototype.srpSessionPost = function (user_param, options) {
        return exports.SessionApiFp(this.configuration).srpSessionPost(user_param, options)(this.fetch, this.basePath);
    };
    return SessionApi;
}(BaseAPI));
exports.SessionApi = SessionApi;
/**
 * SharedKeyApi - fetch parameter creator
 * @export
 */
exports.SharedKeyApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Claims a shared key
         * @param {string} external_id
         * @param {PostSharedKeysClaimKeyRequest} [claim_key_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedKeysExternalIdClaimKeyPost: function (external_id, claim_key_params, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'external_id' is not null or undefined
            if (external_id === null || external_id === undefined) {
                throw new RequiredError('external_id', 'Required parameter external_id was null or undefined when calling sharedKeysExternalIdClaimKeyPost.');
            }
            var localVarPath = "/shared_keys/{external_id}/claim_key"
                .replace("{" + "external_id" + "}", encodeURIComponent(String(external_id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostSharedKeysClaimKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(claim_key_params || {}) : (claim_key_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a shared key
         * @param {PostSharedKeysRequest} [create_shared_key_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedKeysPost: function (create_shared_key_params, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/shared_keys";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostSharedKeysRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(create_shared_key_params || {}) : (create_shared_key_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SharedKeyApi - functional programming interface
 * @export
 */
exports.SharedKeyApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Claims a shared key
         * @param {string} external_id
         * @param {PostSharedKeysClaimKeyRequest} [claim_key_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedKeysExternalIdClaimKeyPost: function (external_id, claim_key_params, options) {
            var localVarFetchArgs = exports.SharedKeyApiFetchParamCreator(configuration).sharedKeysExternalIdClaimKeyPost(external_id, claim_key_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Creates a shared key
         * @param {PostSharedKeysRequest} [create_shared_key_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedKeysPost: function (create_shared_key_params, options) {
            var localVarFetchArgs = exports.SharedKeyApiFetchParamCreator(configuration).sharedKeysPost(create_shared_key_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * SharedKeyApi - factory interface
 * @export
 */
exports.SharedKeyApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Claims a shared key
         * @param {string} external_id
         * @param {PostSharedKeysClaimKeyRequest} [claim_key_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedKeysExternalIdClaimKeyPost: function (external_id, claim_key_params, options) {
            return exports.SharedKeyApiFp(configuration).sharedKeysExternalIdClaimKeyPost(external_id, claim_key_params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a shared key
         * @param {PostSharedKeysRequest} [create_shared_key_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedKeysPost: function (create_shared_key_params, options) {
            return exports.SharedKeyApiFp(configuration).sharedKeysPost(create_shared_key_params, options)(fetch, basePath);
        },
    };
};
/**
 * SharedKeyApi - object-oriented interface
 * @export
 * @class SharedKeyApi
 * @extends {BaseAPI}
 */
var SharedKeyApi = /** @class */ (function (_super) {
    __extends(SharedKeyApi, _super);
    function SharedKeyApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Claims a shared key
     * @param {string} external_id
     * @param {PostSharedKeysClaimKeyRequest} [claim_key_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedKeyApi
     */
    SharedKeyApi.prototype.sharedKeysExternalIdClaimKeyPost = function (external_id, claim_key_params, options) {
        return exports.SharedKeyApiFp(this.configuration).sharedKeysExternalIdClaimKeyPost(external_id, claim_key_params, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Creates a shared key
     * @param {PostSharedKeysRequest} [create_shared_key_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedKeyApi
     */
    SharedKeyApi.prototype.sharedKeysPost = function (create_shared_key_params, options) {
        return exports.SharedKeyApiFp(this.configuration).sharedKeysPost(create_shared_key_params, options)(this.fetch, this.basePath);
    };
    return SharedKeyApi;
}(BaseAPI));
exports.SharedKeyApi = SharedKeyApi;
/**
 * UserApi - fetch parameter creator
 * @export
 */
exports.UserApiFetchParamCreator = function (configuration) {
    return {
        /**
         * A Vault user account is created by the external party, this is a backend-to-backend call. In order to perform this call the external party must possess a `provider_api_key`.
         * @summary Creates a user account
         * @param {PostAdminUsersRequest} [admin_create_user_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersPost: function (admin_create_user_params, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/admin/users";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostAdminUsersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(admin_create_user_params || {}) : (admin_create_user_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A Vault user account is created by the external party, this is a backend-to-backend call. In order to perform this call the external party must possess a `provider_api_key`.
         * @summary Creates a user account
         * @param {PostResellerUserCreateRequest} [reseller_user_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portalServiceV1ResellerUserCreatePost: function (reseller_user_params, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/portal-service/v1/reseller/user/create";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostResellerUserCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(reseller_user_params || {}) : (reseller_user_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an SRP challenge to authenticate with for a given username (Secure Remote Password)
         * @summary Creates a challenge for SRP user auth
         * @param {PostSrpChallengesRequest} [challenge]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        srpChallengesPost: function (challenge, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/srp/challenges";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostSrpChallengesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(challenge || {}) : (challenge || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a username for use on the POST /srp/users endpoint
         * @summary Creates a username for use with SRP auth
         * @param {PostSrpUsernameRequest} [create_username_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        srpUsernamePost: function (create_username_params, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/srp/username";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostSrpUsernameRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(create_username_params || {}) : (create_username_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a user acception only SRP (Secure Remote Password) authentication
         * @summary Creates a user using SRP auth
         * @param {PostSrpUsersRequest} [create_user_with_srp_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        srpUsersPost: function (create_user_with_srp_params, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/srp/users";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostSrpUsersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(create_user_with_srp_params || {}) : (create_user_with_srp_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the current user from the queue for asynchronous deletion.
         * @summary removes a user from queue for deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeletionQueueDelete: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/users/deletion_queue";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queues the current user for asynchronous deletion.
         * @summary Queues a user for deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeletionQueuePost: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/users/deletion_queue";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            // authentication userAuthToken required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a user
         * @param {PostUsersRequest} [create_user_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: function (create_user_params, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/users";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PostUsersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(create_user_params || {}) : (create_user_params || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
exports.UserApiFp = function (configuration) {
    return {
        /**
         * A Vault user account is created by the external party, this is a backend-to-backend call. In order to perform this call the external party must possess a `provider_api_key`.
         * @summary Creates a user account
         * @param {PostAdminUsersRequest} [admin_create_user_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersPost: function (admin_create_user_params, options) {
            var localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).adminUsersPost(admin_create_user_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A Vault user account is created by the external party, this is a backend-to-backend call. In order to perform this call the external party must possess a `provider_api_key`.
         * @summary Creates a user account
         * @param {PostResellerUserCreateRequest} [reseller_user_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portalServiceV1ResellerUserCreatePost: function (reseller_user_params, options) {
            var localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).portalServiceV1ResellerUserCreatePost(reseller_user_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates an SRP challenge to authenticate with for a given username (Secure Remote Password)
         * @summary Creates a challenge for SRP user auth
         * @param {PostSrpChallengesRequest} [challenge]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        srpChallengesPost: function (challenge, options) {
            var localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).srpChallengesPost(challenge, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a username for use on the POST /srp/users endpoint
         * @summary Creates a username for use with SRP auth
         * @param {PostSrpUsernameRequest} [create_username_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        srpUsernamePost: function (create_username_params, options) {
            var localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).srpUsernamePost(create_username_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a user acception only SRP (Secure Remote Password) authentication
         * @summary Creates a user using SRP auth
         * @param {PostSrpUsersRequest} [create_user_with_srp_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        srpUsersPost: function (create_user_with_srp_params, options) {
            var localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).srpUsersPost(create_user_with_srp_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Removes the current user from the queue for asynchronous deletion.
         * @summary removes a user from queue for deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeletionQueueDelete: function (options) {
            var localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).usersDeletionQueueDelete(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queues the current user for asynchronous deletion.
         * @summary Queues a user for deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeletionQueuePost: function (options) {
            var localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).usersDeletionQueuePost(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Creates a user
         * @param {PostUsersRequest} [create_user_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: function (create_user_params, options) {
            var localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).usersPost(create_user_params, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
exports.UserApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * A Vault user account is created by the external party, this is a backend-to-backend call. In order to perform this call the external party must possess a `provider_api_key`.
         * @summary Creates a user account
         * @param {PostAdminUsersRequest} [admin_create_user_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersPost: function (admin_create_user_params, options) {
            return exports.UserApiFp(configuration).adminUsersPost(admin_create_user_params, options)(fetch, basePath);
        },
        /**
         * A Vault user account is created by the external party, this is a backend-to-backend call. In order to perform this call the external party must possess a `provider_api_key`.
         * @summary Creates a user account
         * @param {PostResellerUserCreateRequest} [reseller_user_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portalServiceV1ResellerUserCreatePost: function (reseller_user_params, options) {
            return exports.UserApiFp(configuration).portalServiceV1ResellerUserCreatePost(reseller_user_params, options)(fetch, basePath);
        },
        /**
         * Creates an SRP challenge to authenticate with for a given username (Secure Remote Password)
         * @summary Creates a challenge for SRP user auth
         * @param {PostSrpChallengesRequest} [challenge]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        srpChallengesPost: function (challenge, options) {
            return exports.UserApiFp(configuration).srpChallengesPost(challenge, options)(fetch, basePath);
        },
        /**
         * Creates a username for use on the POST /srp/users endpoint
         * @summary Creates a username for use with SRP auth
         * @param {PostSrpUsernameRequest} [create_username_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        srpUsernamePost: function (create_username_params, options) {
            return exports.UserApiFp(configuration).srpUsernamePost(create_username_params, options)(fetch, basePath);
        },
        /**
         * Creates a user acception only SRP (Secure Remote Password) authentication
         * @summary Creates a user using SRP auth
         * @param {PostSrpUsersRequest} [create_user_with_srp_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        srpUsersPost: function (create_user_with_srp_params, options) {
            return exports.UserApiFp(configuration).srpUsersPost(create_user_with_srp_params, options)(fetch, basePath);
        },
        /**
         * Removes the current user from the queue for asynchronous deletion.
         * @summary removes a user from queue for deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeletionQueueDelete: function (options) {
            return exports.UserApiFp(configuration).usersDeletionQueueDelete(options)(fetch, basePath);
        },
        /**
         * Queues the current user for asynchronous deletion.
         * @summary Queues a user for deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeletionQueuePost: function (options) {
            return exports.UserApiFp(configuration).usersDeletionQueuePost(options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a user
         * @param {PostUsersRequest} [create_user_params]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: function (create_user_params, options) {
            return exports.UserApiFp(configuration).usersPost(create_user_params, options)(fetch, basePath);
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
var UserApi = /** @class */ (function (_super) {
    __extends(UserApi, _super);
    function UserApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * A Vault user account is created by the external party, this is a backend-to-backend call. In order to perform this call the external party must possess a `provider_api_key`.
     * @summary Creates a user account
     * @param {PostAdminUsersRequest} [admin_create_user_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    UserApi.prototype.adminUsersPost = function (admin_create_user_params, options) {
        return exports.UserApiFp(this.configuration).adminUsersPost(admin_create_user_params, options)(this.fetch, this.basePath);
    };
    /**
     * A Vault user account is created by the external party, this is a backend-to-backend call. In order to perform this call the external party must possess a `provider_api_key`.
     * @summary Creates a user account
     * @param {PostResellerUserCreateRequest} [reseller_user_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    UserApi.prototype.portalServiceV1ResellerUserCreatePost = function (reseller_user_params, options) {
        return exports.UserApiFp(this.configuration).portalServiceV1ResellerUserCreatePost(reseller_user_params, options)(this.fetch, this.basePath);
    };
    /**
     * Creates an SRP challenge to authenticate with for a given username (Secure Remote Password)
     * @summary Creates a challenge for SRP user auth
     * @param {PostSrpChallengesRequest} [challenge]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    UserApi.prototype.srpChallengesPost = function (challenge, options) {
        return exports.UserApiFp(this.configuration).srpChallengesPost(challenge, options)(this.fetch, this.basePath);
    };
    /**
     * Creates a username for use on the POST /srp/users endpoint
     * @summary Creates a username for use with SRP auth
     * @param {PostSrpUsernameRequest} [create_username_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    UserApi.prototype.srpUsernamePost = function (create_username_params, options) {
        return exports.UserApiFp(this.configuration).srpUsernamePost(create_username_params, options)(this.fetch, this.basePath);
    };
    /**
     * Creates a user acception only SRP (Secure Remote Password) authentication
     * @summary Creates a user using SRP auth
     * @param {PostSrpUsersRequest} [create_user_with_srp_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    UserApi.prototype.srpUsersPost = function (create_user_with_srp_params, options) {
        return exports.UserApiFp(this.configuration).srpUsersPost(create_user_with_srp_params, options)(this.fetch, this.basePath);
    };
    /**
     * Removes the current user from the queue for asynchronous deletion.
     * @summary removes a user from queue for deletion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    UserApi.prototype.usersDeletionQueueDelete = function (options) {
        return exports.UserApiFp(this.configuration).usersDeletionQueueDelete(options)(this.fetch, this.basePath);
    };
    /**
     * Queues the current user for asynchronous deletion.
     * @summary Queues a user for deletion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    UserApi.prototype.usersDeletionQueuePost = function (options) {
        return exports.UserApiFp(this.configuration).usersDeletionQueuePost(options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Creates a user
     * @param {PostUsersRequest} [create_user_params]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    UserApi.prototype.usersPost = function (create_user_params, options) {
        return exports.UserApiFp(this.configuration).usersPost(create_user_params, options)(this.fetch, this.basePath);
    };
    return UserApi;
}(BaseAPI));
exports.UserApi = UserApi;
/**
 * VersionApi - fetch parameter creator
 * @export
 */
exports.VersionApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns the API version and the component name
         * @summary Returns the API version and the component name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionGet: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/version";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication subscriptionKey required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Meeco-Subscription-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["Meeco-Subscription-Key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * VersionApi - functional programming interface
 * @export
 */
exports.VersionApiFp = function (configuration) {
    return {
        /**
         * Returns the API version and the component name
         * @summary Returns the API version and the component name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionGet: function (options) {
            var localVarFetchArgs = exports.VersionApiFetchParamCreator(configuration).versionGet(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * VersionApi - factory interface
 * @export
 */
exports.VersionApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Returns the API version and the component name
         * @summary Returns the API version and the component name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionGet: function (options) {
            return exports.VersionApiFp(configuration).versionGet(options)(fetch, basePath);
        },
    };
};
/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
var VersionApi = /** @class */ (function (_super) {
    __extends(VersionApi, _super);
    function VersionApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the API version and the component name
     * @summary Returns the API version and the component name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    VersionApi.prototype.versionGet = function (options) {
        return exports.VersionApiFp(this.configuration).versionGet(options)(this.fetch, this.basePath);
    };
    return VersionApi;
}(BaseAPI));
exports.VersionApi = VersionApi;
/**
 * WellKnownApi - fetch parameter creator
 * @export
 */
exports.WellKnownApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
         * @summary Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wellKnownRecaptchaGet: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/.well-known/recaptcha";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * WellKnownApi - functional programming interface
 * @export
 */
exports.WellKnownApiFp = function (configuration) {
    return {
        /**
         * Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
         * @summary Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wellKnownRecaptchaGet: function (options) {
            var localVarFetchArgs = exports.WellKnownApiFetchParamCreator(configuration).wellKnownRecaptchaGet(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * WellKnownApi - factory interface
 * @export
 */
exports.WellKnownApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
         * @summary Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wellKnownRecaptchaGet: function (options) {
            return exports.WellKnownApiFp(configuration).wellKnownRecaptchaGet(options)(fetch, basePath);
        },
    };
};
/**
 * WellKnownApi - object-oriented interface
 * @export
 * @class WellKnownApi
 * @extends {BaseAPI}
 */
var WellKnownApi = /** @class */ (function (_super) {
    __extends(WellKnownApi, _super);
    function WellKnownApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
     * @summary Gets recaptcha settings (mainly site key to be used for recaptcha verifications)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WellKnownApi
     */
    WellKnownApi.prototype.wellKnownRecaptchaGet = function (options) {
        return exports.WellKnownApiFp(this.configuration).wellKnownRecaptchaGet(options)(this.fetch, this.basePath);
    };
    return WellKnownApi;
}(BaseAPI));
exports.WellKnownApi = WellKnownApi;
