'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var cryppo = require('@meeco/cryppo');
var jsrp = require('jsrp');
var Keystore = require('@meeco/keystore-api-sdk');
var Vault = require('@meeco/vault-api-sdk');
var chalk = require('chalk');
var debug = require('debug');
var Jimp = require('jimp');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/**
 * `AuthData` is a container for all the data required to perform actions on behalf of a Meeco User.
 *
 * *Note:* Actual `AuthData` passed to method calls doesn't need to be an instance of this class - it can just conform to the interface.
 */
var AuthData = function AuthData(config) {
  _classCallCheck(this, AuthData);

  this.data_encryption_key = config.data_encryption_key;
  this.key_encryption_key = config.key_encryption_key;
  this.keystore_access_token = config.keystore_access_token;
  this.passphrase_derived_key = config.passphrase_derived_key;
  this.secret = config.secret;
  this.vault_access_token = config.vault_access_token;
};

var ConnectionCreateData = function ConnectionCreateData(from, to, options) {
  _classCallCheck(this, ConnectionCreateData);

  this.from = from;
  this.to = to;
  this.options = options;
};

/**
 *
 * Mockable cryppo
 *
 * ES6 module imports can not be stubbed with certain cobinations of TypeScript/sinon/etc.
 * https://github.com/sinonjs/sinon/issues/1711
 *
 * By having an intermediate module we can use `sinon.stub` to mock cryppo methods in tests
 * @hidden
 */

var _cryppo = Object.assign({}, cryppo);

/**
 * An key that can be used to encrypt and decrypt data travelling to and from Meeco's services.
 * This wrapper ensures that keys can be safely serialized as JSON (by encoding them as URL-Safe Base64)
 * and avoids confusion when dealing with converting to and from this encoded format.
 */

var EncryptionKey = /*#__PURE__*/function () {
  /**
   * The constructor is intentionally private as we want the user ot be explicit as to whether the value coming
   * in is raw bytes or a base64 encoded version.
   *
   * @param _value  Value as binary string. Avoid outputting to console but should be used for actual encryption.
   */
  function EncryptionKey(_value) {
    _classCallCheck(this, EncryptionKey);

    this._value = _value;
  }
  /**
   * Create an {@link EncryptionKey} from encoded URL-safe base 64 version of the key
   */


  _createClass(EncryptionKey, [{
    key: "toJSON",

    /**
     * Implicitly called by `JSON.stringify()` to ensure that the value is safely printable
     */
    value: function toJSON(key) {
      return _cryppo.encodeSafe64(this._value);
    }
  }, {
    key: "key",

    /**
     * Return the actual encryption key to be used for encryption/decryption
     */
    get: function get() {
      return this._value;
    }
  }], [{
    key: "fromSerialized",
    value: function fromSerialized(value) {
      return new EncryptionKey(_cryppo.decodeSafe64(value || ''));
    }
    /**
     * Create an {@link EncryptionKey} from a binary string version of the key
     */

  }, {
    key: "fromRaw",
    value: function fromRaw(value) {
      return new EncryptionKey(value);
    }
  }]);

  return EncryptionKey;
}();

/**
 * Environment configuration - used to point to the desired API host (e.g sandbox or production) and configure
 * your subscription keys for API access.
 */
var Environment = function Environment(config) {
  _classCallCheck(this, Environment);

  this.vault = config.vault;
  this.keystore = config.keystore;
};

var FileAttachmentData = function FileAttachmentData(config) {
  _classCallCheck(this, FileAttachmentData);

  this.itemId = config.itemId;
  this.label = config.label;
  this.file = config.file;
  this.fileName = config.fileName;
  this.fileType = config.fileType;
};

var ItemCreateData = function ItemCreateData(config) {
  _classCallCheck(this, ItemCreateData);

  this.template_name = config.template_name;
  this.item = config.item;
  this.slots = config.slots || [];
};

var ItemUpdateData = function ItemUpdateData(config) {
  _classCallCheck(this, ItemUpdateData);

  this.id = config.id;
  this.label = config.label;
  this.slots = config.slots || [];
};

var ERROR_CODES = {
  InvalidSecretFormat: 'INVALID_SECRET_FORMAT',
  LoginFailed: 'LOGIN_FAILED'
};
var MeecoServiceError = /*#__PURE__*/function (_Error) {
  _inherits(MeecoServiceError, _Error);

  var _super = _createSuper(MeecoServiceError);

  function MeecoServiceError(message, code) {
    var _this;

    _classCallCheck(this, MeecoServiceError);

    _this = _super.call(this, message);
    _this.code = code;
    return _this;
  }

  return MeecoServiceError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

function _await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

var SRPSession = /*#__PURE__*/function () {
  function SRPSession() {
    _classCallCheck(this, SRPSession);

    this._client = null;
  }
  /**
   * The raw `jsrp` client
   */


  _createClass(SRPSession, [{
    key: "init",
    value: function init(username, passwordDerivedFromPassphrase) {
      try {
        var _this2 = this;

        return _await(_this2.createSrpClient(username, passwordDerivedFromPassphrase), function (_this$createSrpClient) {
          _this2._client = _this$createSrpClient;
          return _this2;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Computes the client public key - Also known as the "srp_a" value
     */

  }, {
    key: "getClientPublic",
    value: function getClientPublic() {
      try {
        var _this4 = this;

        return _this4.client.getPublicKey();
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Computes the client proof from the server challenge - Also known as the "srp_m" value
     */

  }, {
    key: "computeProofFromChallenge",
    value: function computeProofFromChallenge(_ref) {
      var salt = _ref.salt,
          serverPublic = _ref.serverPublic;

      try {
        var _this6 = this;

        _this6.client.setSalt(salt);

        _this6.client.setServerPublicKey(serverPublic);

        return _this6.client.getProof();
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "createVerifier",
    value: function createVerifier() {
      try {
        var _this8 = this;

        return new Promise(function (resolve) {
          _this8.client.createVerifier(function (err, result) {
            resolve(result);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "createSrpClient",
    value: function createSrpClient(username, password) {
      return new Promise(function (resolve) {
        var client = new jsrp.client();
        client.init({
          username: username,
          password: password,
          length: 2048
        }, function () {
          resolve(client);
        });
      });
    }
  }, {
    key: "client",
    get: function get() {
      if (!this._client) {
        throw new Error('Must call SRPSession init() first');
      }

      return this._client;
    }
  }]);

  return SRPSession;
}();

// tslint:disable-next-line: no-var-requires
var FormData = require('form-data');
/**
 * @hidden
 *
 * This exists because of what appears to be an issue in the generated SDK.
 * Attaching a `Buffer()` to `FormData` does not work if the file name property isn't provided
 * (which it isn't in the generated code).
 * This monkey-patches the constructor of FormData to ensure the argument always exists
 */


var SDKFormData = /*#__PURE__*/function (_FormData) {
  _inherits(SDKFormData, _FormData);

  var _super = _createSuper(SDKFormData);

  function SDKFormData() {
    _classCallCheck(this, SDKFormData);

    return _super.apply(this, arguments);
  }

  _createClass(SDKFormData, [{
    key: "append",
    value: function append() {
      var _get2;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args[0] === 'attachment[file]' || args[0] === 'binary[file]') {
        return _get(_getPrototypeOf(SDKFormData.prototype), "append", this).call(this, args[0], args[1], 'file');
      }

      return (_get2 = _get(_getPrototypeOf(SDKFormData.prototype), "append", this)).call.apply(_get2, [this].concat(args));
    }
  }]);

  return SDKFormData;
}(FormData); // We might be able to assume an existing window.FormData works

function _async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

var fetchLib = global.fetch;
/**
 * Configure the fetch library to use for API requests
 */

var configureFetch = function configureFetch(_fetch) {
  return fetchLib = _fetch;
};
var debugCurl = debug.debug('meeco:http');
global.FormData = global.FormData || SDKFormData;
var X_MEECO_API_VERSION = '2.0.0';

var vaultToken = function vaultToken(userAuth) {
  return typeof userAuth === 'string' ? userAuth : userAuth.vault_access_token;
};

var keystoreToken = function keystoreToken(userAuth) {
  return typeof userAuth === 'string' ? userAuth : userAuth.keystore_access_token;
};
/**
 * Pluck environment and user auth values to create `apiKey` [Keystore.Configuration] parameter
 */


var keystoreAPIKeys = function keystoreAPIKeys(environment, userAuth) {
  return function (name) {
    return {
      'Meeco-Subscription-Key': environment.keystore.subscription_key,
      // Must be uppercase
      // prettier-ignore
      'Authorization': keystoreToken(userAuth)
    }[name];
  };
};
/**
 * Pluck environment and user auth values to create `apiKey` [Vault.Configuration] parameter
 */


var vaultAPIKeys = function vaultAPIKeys(environment, userAuth) {
  return function (name) {
    return {
      'Meeco-Subscription-Key': environment.vault.subscription_key,
      // Must be uppercase
      // prettier-ignore
      'Authorization': vaultToken(userAuth)
    }[name];
  };
};

function fetchInterceptor(url, options) {
  debugCurl(chalk.blue("Sending Request:"));
  debugCurl(toCurl(url, options));
  return fetchLib(url, options).then(_async(function (response) {
    debugCurl(chalk.green("Received Response:"));
    debugCurl("status: ".concat(response.status, "\nstatusText: ").concat(response.statusText, "\n"));
    return response;
  }));
}

var callApiWithHeaders = function callApiWithHeaders(sdk, api, apiMethodName, apiKey, basePath, headers, args) {
  var apiInstance = new sdk[api](new Vault.Configuration({
    apiKey: apiKey,
    basePath: basePath,
    middleware: [],
    // openapi-sdk style headers
    headers: headers,
    fetchApi: fetchInterceptor
  }), null, fetchInterceptor);
  var apiMethod = apiInstance[apiMethodName]; // swagger-codegen style headers (Keystore still uses swagger-codegen)

  if (apiInstance.constructor.__proto__ === Keystore.BaseAPI) {
    var argsCount = apiMethod.length;
    var fetchOptions = args[argsCount - 1] || {};
    fetchOptions.headers = Object.assign(Object.assign({}, headers), fetchOptions.headers);
    args[argsCount - 1] = fetchOptions;
  }

  return apiMethod.call.apply(apiMethod, [apiInstance].concat(_toConsumableArray(args)))["catch"](function (err) {
    if (err.status === 426) {
      throw new Error('The API returned 426 and therefore does not support this version of the CLI. Please check for an update to the Meeco CLI.');
    } else {
      throw err;
    }
  });
};
/**
 * Helper for constructing instances of Keystore apis with all the required auth and header params
 */


var keystoreAPI = function keystoreAPI(api, environment, userAuth) {
  var additionalHeaders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return new Proxy({}, {
    get: function get(target, apiMethodName) {
      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return callApiWithHeaders(Keystore, api, apiMethodName, keystoreAPIKeys(environment, userAuth), environment.keystore.url, Object.assign(Object.assign({}, additionalHeaders), {
          X_MEECO_API_VERSION: X_MEECO_API_VERSION,
          X_MEECO_API_COMPONENT: 'keystore'
        }), args);
      };
    }
  });
};
/**
 * Helper for constructing instances of Vault apis with all the required auth and header params
 */


var vaultAPI = function vaultAPI(api, environment, userAuth) {
  var additionalHeaders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return new Proxy({}, {
    get: function get(target, apiMethodName) {
      return function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return callApiWithHeaders(Vault, api, apiMethodName, vaultAPIKeys(environment, userAuth), environment.vault.url, Object.assign(Object.assign({}, additionalHeaders), {
          X_MEECO_API_VERSION: X_MEECO_API_VERSION,
          X_MEECO_API_COMPONENT: 'vault'
        }), args);
      };
    }
  });
};
/**
 * Results in a factory function that can be passed user auth information and then get
 * arbitrary Keystore api instances to use.
 */


var keystoreAPIFactory = function keystoreAPIFactory(environment) {
  return function (userAuth, headers) {
    return new Proxy({}, {
      get: function get(target, property) {
        return keystoreAPI(property, environment, userAuth, headers);
      }
    });
  };
};
/**
 * Results in a factory function that can be passed user auth information and then get
 * arbitrary Vault api instances to use.
 */

var vaultAPIFactory = function vaultAPIFactory(environment) {
  return function (userAuth, headers) {
    return new Proxy({}, {
      get: function get(target, property) {
        return vaultAPI(property, environment, userAuth, headers);
      }
    });
  };
};

var toCurl = function toCurl(url, options) {
  var defaultHeaders = {
    'Content-Type': 'application/json'
  };
  var allHeaders = Object.assign(Object.assign({}, defaultHeaders), options.headers);
  var headersString = Object.keys(allHeaders).map(function (key) {
    return "  --header \"".concat(key, ": ").concat(allHeaders[key], "\"");
  }).join(' \\\n');
  return "curl \\\n  ".concat(headersString.trim(), " \\\n  --request ").concat(options.method, " \\\n  --data ").concat(options.body || '{}', " \\\n  \"").concat(url, "\"\n  ");
};

/**
 * A ClientTask represents a task the client is supposed to perform.
 */

function _await$1(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

var ClientTaskQueueService = /*#__PURE__*/function () {
  function ClientTaskQueueService(environment) {
    _classCallCheck(this, ClientTaskQueueService);

    this.vaultAPIFactory = vaultAPIFactory(environment);
  }

  _createClass(ClientTaskQueueService, [{
    key: "list",
    value: function list(vaultAccessToken) {
      var supressChangingState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.State.Todo;
      return this.vaultAPIFactory(vaultAccessToken).ClientTaskQueueApi.clientTaskQueueGet(undefined, undefined, supressChangingState, state);
    }
  }, {
    key: "countOutstandingTasks",
    value: function countOutstandingTasks(vaultAccessToken) {
      try {
        var _this2 = this;

        return _await$1(_this2.vaultAPIFactory(vaultAccessToken).ClientTaskQueueApi.clientTaskQueueGet(undefined, undefined, true, exports.State.Todo), function (todoTasks) {
          return _await$1(_this2.vaultAPIFactory(vaultAccessToken).ClientTaskQueueApi.clientTaskQueueGet(undefined, undefined, true, exports.State.InProgress), function (inProgressTasks) {
            return {
              todo: todoTasks.client_tasks.length,
              in_progress: inProgressTasks.client_tasks.length
            };
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);

  return ClientTaskQueueService;
}();

(function (State) {
  State["Todo"] = "todo";
  State["InProgress"] = "in_progress";
  State["Done"] = "done";
  State["Failed"] = "failed";
})(exports.State || (exports.State = {}));

function _await$2(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}
/**
 * Helper to find connection between two users (if one exists)
 */


function _async$1(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

function connectionApi(user, environment) {
  return vaultAPIFactory(environment)(user).ConnectionApi;
}

var fetchConnectionWithId = _async$1(function (user, connectionId, environment, log) {
  log('Fetching user connection');
  return _await$2(connectionApi(user, environment).connectionsIdGet(connectionId), function (response) {
    var connection = response.connection;

    if (!connection || !connection.id) {
      throw new Error("Conncetion ".concat(connectionId, " not found."));
    }

    return connection;
  });
});
var findConnectionBetween = _async$1(function (fromUser, toUser, environment, log) {
  log('Fetching from user connections');
  return _await$2(connectionApi(fromUser, environment).connectionsGet(), function (fromUserConnections) {
    log('Fetching to user connections');
    return _await$2(connectionApi(toUser, environment).connectionsGet(), function (toUserConnections) {
      var sharedConnections = fromUserConnections.connections.filter(function (fromConnection) {
        return !!toUserConnections.connections.find(function (toConnection) {
          return fromConnection.public_key === toConnection.other_user_connection_public_key;
        });
      });

      if (sharedConnections.length < 1) {
        throw new Error('Users are not connected. Please set up a connection first.');
      }

      var _sharedConnections = _slicedToArray(sharedConnections, 1),
          fromUserConnection = _sharedConnections[0];

      var toUserConnection = toUserConnections.connections.find(function (toConnection) {
        return fromUserConnection.public_key === toConnection.other_user_connection_public_key;
      });

      if (!toUserConnection) {
        throw new Error('To user connection not found. Invitation may not have been accepted');
      }

      return {
        fromUserConnection: fromUserConnection,
        toUserConnection: toUserConnection
      };
    });
  });
});

/**
 * Used for setting up connections between Meeco `User`s to allow the secure sharing of data (see also {@link ShareService})
 */

function _await$3(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

function _empty() {}

function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

function _continue(value, then) {
  return value && value.then ? value.then(then) : then(value);
}

var ConnectionService = /*#__PURE__*/function () {
  function ConnectionService(environment) {
    var log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

    _classCallCheck(this, ConnectionService);

    this.environment = environment;
    this.log = log;
    this.cryppo = global.cryppo || _cryppo;
    this.vaultApiFactory = vaultAPIFactory(environment);
    this.keystoreApiFactory = keystoreAPIFactory(environment);
  }

  _createClass(ConnectionService, [{
    key: "createInvitation",
    value: function createInvitation(name, auth) {
      try {
        var _this2 = this;

        _this2.log('Generating key pair');

        return _await$3(_this2.createAndStoreKeyPair(auth), function (keyPair) {
          _this2.log('Encrypting recipient name');

          return _await$3(_this2.encryptRecipientName(name, auth), function (encryptedName) {
            _this2.log('Sending invitation request');

            return _await$3(_this2.vaultApiFactory(auth).InvitationApi.invitationsPost({
              public_key: {
                keypair_external_id: keyPair.keystoreStoredKeyPair.id,
                public_key: keyPair.keyPair.publicKey
              },
              invitation: {
                encrypted_recipient_name: encryptedName
              }
            }).then(function (result) {
              return result.invitation;
            }));
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "acceptInvitation",
    value: function acceptInvitation(name, invitationToken, auth) {
      try {
        var _this4 = this;

        _this4.log('Generating key pair');

        return _await$3(_this4.createAndStoreKeyPair(auth), function (keyPair) {
          _this4.log('Encrypting connection name');

          return _await$3(_this4.encryptRecipientName(name, auth), function (encryptedName) {
            _this4.log('Accepting invitation');

            return _await$3(_this4.vaultApiFactory(auth).ConnectionApi.connectionsPost({
              public_key: {
                keypair_external_id: keyPair.keystoreStoredKeyPair.id,
                public_key: keyPair.keyPair.publicKey
              },
              connection: {
                encrypted_recipient_name: encryptedName,
                invitation_token: invitationToken
              }
            }).then(function (res) {
              return res.connection;
            }));
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Note this only works if we have authentication data for both connecting users.
     * For more typical use cases you should manually call {@link createInvitation}
     * as one user and {@link acceptInvitation} as the other user.
     */

  }, {
    key: "createConnection",
    value: function createConnection(config) {
      try {
        var _this6 = this;

        var to = config.to,
            from = config.from,
            options = config.options;
        var existingConnection;
        return _continue(_catch(function () {
          // We want to avoid creating keypairs etc. only to find out that the users were connected from the beginning
          _this6.log('Checking for an existing connection');

          return _await$3(findConnectionBetween(from, to, _this6.environment, _this6.log), function (_findConnectionBetwee) {
            existingConnection = _findConnectionBetwee;
          });
        }, _empty), function () {
          // @ts-ignore
          if ((existingConnection === null || existingConnection === void 0 ? void 0 : existingConnection.fromUserConnection) && (existingConnection === null || existingConnection === void 0 ? void 0 : existingConnection.toUserConnection)) {
            throw new Error('Connection exists between the specified users');
          }

          return _await$3(_this6.createInvitation(options.toName, from), function (invitation) {
            return _await$3(_this6.acceptInvitation(options.fromName, invitation.token, to), function () {
              // Now the connection has been created we need to re-fetch the original user's connection.
              // We might as well fetch both to ensure it's connected both ways correctly.
              return _await$3(findConnectionBetween(from, to, _this6.environment, _this6.log), function (_ref) {
                var fromUserConnection = _ref.fromUserConnection,
                    toUserConnection = _ref.toUserConnection;
                return {
                  invitation: invitation,
                  fromUserConnection: fromUserConnection,
                  toUserConnection: toUserConnection,
                  options: options
                };
              });
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "listConnections",
    value: function listConnections(user) {
      try {
        var _this8 = this;

        _this8.log('Fetching connections');

        return _await$3(_this8.vaultApiFactory(user).ConnectionApi.connectionsGet(), function (result) {
          _this8.log('Decrypting connection names');

          var decryptions = (result.connections || []).map(function (connection) {
            return _this8.cryppo.decryptWithKey({
              serialized: connection.encrypted_recipient_name,
              key: user.data_encryption_key.key
            }).then(function (name) {
              return {
                name: name,
                connection: connection
              };
            });
          });
          return Promise.all(decryptions);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "encryptRecipientName",
    value: function encryptRecipientName(name, user) {
      return this.cryppo.encryptWithKey({
        data: name,
        key: user.data_encryption_key.key,
        strategy: this.cryppo.CipherStrategy.AES_GCM
      }).then(function (result) {
        return result.serialized;
      });
    }
  }, {
    key: "createAndStoreKeyPair",
    value: function createAndStoreKeyPair(user) {
      try {
        var _this10 = this;

        return _await$3(_this10.cryppo.generateRSAKeyPair(), function (keyPair) {
          return _await$3(_this10.cryppo.encryptWithKey({
            data: keyPair.privateKey,
            key: user.key_encryption_key.key,
            strategy: _this10.cryppo.CipherStrategy.AES_GCM
          }), function (toPrivateKeyEncrypted) {
            return _await$3(_this10.keystoreApiFactory(user).KeypairApi.keypairsPost({
              public_key: keyPair.publicKey,
              encrypted_serialized_key: toPrivateKeyEncrypted.serialized,
              // API will 500 without
              metadata: {},
              external_identifiers: []
            }).then(function (result) {
              return result.keypair;
            }), function (keystoreStoredKeyPair) {
              return {
                keyPair: keyPair,
                keystoreStoredKeyPair: keystoreStoredKeyPair
              };
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);

  return ConnectionService;
}();

/**
 * Used for fetching and sending `Items` to and from the Vault.
 */

function _await$4(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

function _catch$1(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

function _continue$1(value, then) {
  return value && value.then ? value.then(then) : then(value);
}

function _empty$1() {}

function _awaitIgnored(value, direct) {
  if (!direct) {
    return value && value.then ? value.then(_empty$1) : Promise.resolve();
  }
}

function _continueIgnored(value) {
  if (value && value.then) {
    return value.then(_empty$1);
  }
}

function _invoke(body, then) {
  var result = body();

  if (result && result.then) {
    return result.then(then);
  }

  return then(result);
}

function _call(body, then, direct) {
  if (direct) {
    return then ? then(body()) : body();
  }

  try {
    var result = Promise.resolve(body());
    return then ? result.then(then) : result;
  } catch (e) {
    return Promise.reject(e);
  }
}

function _async$2(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

var ItemService = /*#__PURE__*/function () {
  function ItemService(environment) {
    var log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

    _classCallCheck(this, ItemService);

    this.log = log;
    this.vaultAPIFactory = vaultAPIFactory(environment);
  }
  /**
   * Updates 'value' to the decrypted 'encrypted_value' and sets 'encrypted' to false.
   */


  _createClass(ItemService, [{
    key: "create",
    value: function create(vaultAccessToken, dek, config) {
      try {
        var _this2 = this;

        return _await$4(Promise.all((config.slots || []).map(function (slot) {
          return _this2.encryptSlot(slot, dek);
        })), function (slots_attributes) {
          return _await$4(_this2.vaultAPIFactory(vaultAccessToken).ItemApi.itemsPost({
            template_name: config.template_name,
            item: {
              label: config.item.label,
              slots_attributes: slots_attributes
            }
          }));
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "update",
    value: function update(vaultAccessToken, dek, config) {
      try {
        var _this4 = this;

        return _await$4(Promise.all((config.slots || []).map(function (slot) {
          return _this4.encryptSlot(slot, dek);
        })), function (slots_attributes) {
          return _await$4(_this4.vaultAPIFactory(vaultAccessToken).ItemApi.itemsIdPut(config.id, {
            item: {
              label: config.label,
              slots_attributes: slots_attributes
            }
          }));
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "generateAndUploadThumbnail",
    value: function generateAndUploadThumbnail(file, binaryId, auth) {
      try {
        var _this6 = this;

        var targetThumbnailSize = 256;
        var sizeType = "png_".concat(targetThumbnailSize, "x").concat(targetThumbnailSize);

        _this6.log('Generating image thumbnail');

        return _await$4(Jimp.read(file), function (jimp) {
          return _await$4(jimp.resize(targetThumbnailSize, targetThumbnailSize).getBufferAsync(Jimp.MIME_PNG), function (thumbnail) {
            _this6.log('Encrypting image thumbnail');

            return _await$4(ItemService.cryppo.encryptWithKey({
              key: auth.data_encryption_key.key,
              data: ItemService.cryppo.binaryBufferToString(thumbnail),
              strategy: ItemService.cryppo.CipherStrategy.AES_GCM
            }), function (encryptedThumbnail) {
              var _exit = false;

              _this6.log('Uploading encrypted image thumbnail');

              var response;
              return _continue$1(_catch$1(function () {
                var blob = typeof Blob === 'function' ? new Blob([encryptedThumbnail.serialized]) : Buffer.from(encryptedThumbnail.serialized, 'binary');
                return _await$4(_this6.vaultAPIFactory(auth).ThumbnailApi.thumbnailsPost(blob, binaryId, sizeType), function (_this5$vaultAPIFactor) {
                  response = _this5$vaultAPIFactor;
                });
              }, function (err) {
                _this6.log('Error uploading encrypted thumbnail file!');

                throw err;
              }), function (_result) {
                return _exit ? _result : response;
              });
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "attachFile",
    value: function attachFile(config, auth) {
      try {
        var _this8 = this;

        var itemId = config.itemId,
            label = config.label,
            file = config.file,
            fileName = config.fileName,
            fileType = config.fileType;

        _this8.log('Reading file');

        _this8.log('Fetching item');

        return _await$4(_this8.get(itemId, auth.vault_access_token, auth.data_encryption_key)["catch"](function (err) {
          throw new MeecoServiceError("Unable to find item '".concat(itemId, "' - please check that the item exists for the current user."));
        }), function (itemFetchResult) {
          _this8.log('Encrypting File');

          return _await$4(ItemService.cryppo.encryptWithKey({
            key: auth.data_encryption_key.key,
            data: ItemService.cryppo.binaryBufferToString(file),
            strategy: ItemService.cryppo.CipherStrategy.AES_GCM
          }), function (encryptedFile) {
            var _exit2 = false;
            var uploadedBinary;
            return _continue$1(_catch$1(function () {
              _this8.log('Uploading encrypted file');

              var blob = typeof Blob === 'function' ? new Blob([encryptedFile.serialized]) : Buffer.from(encryptedFile.serialized, 'binary');
              return _await$4(_this8.vaultAPIFactory(auth.vault_access_token).AttachmentApi.attachmentsPost(blob, fileName, fileType), function (_this7$vaultAPIFactor) {
                uploadedBinary = _this7$vaultAPIFactor;
              });
            }, function (err) {
              _this8.log('Upload encrypted file failed - removing temp encrypted version');

              throw err;
            }), function (_result2) {
              return _exit2 ? _result2 : _invoke(function () {
                if (fileType.startsWith('image/')) {
                  return _continueIgnored(_catch$1(function () {
                    return _awaitIgnored(_this8.generateAndUploadThumbnail(file, uploadedBinary.attachment.id, auth));
                  }, function (err) {
                    console.log('Creating thumbnail failed - continuing without thumbnail');
                    console.log(err.message);
                  }));
                }
              }, function () {
                _this8.log('Adding attachment to item');

                return _await$4(_this8.vaultAPIFactory(auth.vault_access_token).ItemApi.itemsIdPut(itemFetchResult.item.id, {
                  item: {
                    slots_attributes: [{
                      label: label,
                      slot_type_name: 'attachment',
                      attachments_attributes: [{
                        id: uploadedBinary.attachment.id
                      }]
                    }]
                  }
                }), function (updated) {
                  _this8.log('File was successfully attached');

                  return updated;
                });
              });
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "downloadAndDecryptFile",
    value: function downloadAndDecryptFile(download, dataEncryptionKey) {
      return _call(download, function (result) {
        return _await$4(result.arrayBuffer(), function (buffer) {
          return _await$4(ItemService.cryppo.binaryBufferToString(buffer), function (encryptedContents) {
            return _await$4(ItemService.cryppo.decryptWithKey({
              serialized: encryptedContents,
              key: dataEncryptionKey.key
            }));
          });
        });
      });
    }
  }, {
    key: "downloadAttachment",
    value: function downloadAttachment(id, vaultAccessToken, dataEncryptionKey) {
      try {
        var _this10 = this;

        _this10.log('Downloading attachment');

        return _this10.downloadAndDecryptFile(function () {
          return _this10.vaultAPIFactory(vaultAccessToken).AttachmentApi.attachmentsIdDownloadGet(id);
        }, dataEncryptionKey);
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "downloadThumbnail",
    value: function downloadThumbnail(id, vaultAccessToken, dataEncryptionKey) {
      try {
        var _this12 = this;

        _this12.log('Downloading thumbnail');

        return _this12.downloadAndDecryptFile(function () {
          return _this12.vaultAPIFactory(vaultAccessToken).ThumbnailApi.thumbnailsIdGet(id);
        }, dataEncryptionKey);
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "removeSlot",
    value: function removeSlot(slotId, vaultAccessToken) {
      try {
        var _this14 = this;

        _this14.log('Removing slot');

        return _await$4(_this14.vaultAPIFactory(vaultAccessToken).SlotApi.slotsIdDelete(slotId), function () {
          _this14.log('Slot successfully removed');
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "get",
    value: function get(id, vaultAccessToken, dataEncryptionKey) {
      try {
        var _this16 = this;

        return _await$4(_this16.vaultAPIFactory(vaultAccessToken).ItemApi.itemsIdGet(id), function (result) {
          return _await$4(ItemService.decryptAllSlots(result.slots, dataEncryptionKey), function (slots) {
            return Object.assign(Object.assign({}, result), {
              slots: slots
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "encryptSlot",
    value: function encryptSlot(slot, dek) {
      try {
        var encrypted = Object.assign({}, slot);
        return _await$4(ItemService.cryppo.encryptWithKey({
          strategy: ItemService.cryppo.CipherStrategy.AES_GCM,
          key: dek.key,
          data: slot.value || ''
        }).then(function (result) {
          return result.serialized;
        }), function (_ItemService$cryppo$e) {
          encrypted.encrypted_value = _ItemService$cryppo$e;
          delete encrypted.value;
          encrypted.encrypted = true;
          return encrypted;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "list",
    value: function list(vaultAccessToken) {
      return this.vaultAPIFactory(vaultAccessToken).ItemApi.itemsGet();
    }
  }], [{
    key: "decryptAllSlots",
    value: function decryptAllSlots(slots, dataEncryptionKey) {
      var _this17 = this;

      return Promise.all(slots.map(_async$2(function (slot) {
        var _temp // need to check encrypted_value as binaries will also have `encrypted: true`
        = slot.encrypted && slot.encrypted_value !== null;

        return _await$4(_temp ? _this17.cryppo.decryptWithKey({
          key: dataEncryptionKey.key,
          serialized: slot.encrypted_value
        }) : slot.value, function (value) {
          var decrypted = Object.assign(Object.assign({}, slot), {
            encrypted: false,
            value: value
          });
          return decrypted;
        }, !_temp);
      })));
    }
  }]);

  return ItemService;
}();
ItemService.cryppo = global.cryppo || _cryppo;

/**
 * Manage organizations from the API.
 */

function _await$5(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

var OrganizationServicesService = /*#__PURE__*/function () {
  function OrganizationServicesService(environment, vaultAccessToken) {
    _classCallCheck(this, OrganizationServicesService);

    // for mocking during testing
    this.cryppo = global.cryppo || _cryppo;
    this.api = vaultAPIFactory(environment)(vaultAccessToken).OrganizationsManagingServicesApi;
  }

  _createClass(OrganizationServicesService, [{
    key: "getLogin",
    value: function getLogin(organizationId, serviceId, privateKey) {
      try {
        var _this2 = this;

        return _await$5(_this2.api.organizationsOrganizationIdServicesIdLoginPost(organizationId, serviceId), function (result) {
          return _await$5(_this2.cryppo.decryptSerializedWithPrivateKey({
            privateKeyPem: privateKey,
            serialized: result.encrypted_access_token
          }), function (decryptedVaultSessionToken) {
            return new AuthData({
              secret: '',
              keystore_access_token: '',
              vault_access_token: decryptedVaultSessionToken,
              data_encryption_key: EncryptionKey.fromRaw(''),
              key_encryption_key: EncryptionKey.fromRaw(''),
              passphrase_derived_key: EncryptionKey.fromRaw('')
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "create",
    value: function create(organizationId, service) {
      try {
        var _this4 = this;

        return _await$5(_this4.cryppo.generateRSAKeyPair(4096), function (rsaKeyPair) {
          service.public_key = rsaKeyPair.publicKey;
          return _await$5(_this4.api.organizationsOrganizationIdServicesPost(organizationId, {
            service: service
          }), function (result) {
            return {
              service: result.service,
              privateKey: rsaKeyPair.privateKey,
              publicKey: rsaKeyPair.publicKey
            };
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);

  return OrganizationServicesService;
}();

/**
 * Manage organizations from the API.
 */

function _await$6(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

var OrganizationsService = /*#__PURE__*/function () {
  function OrganizationsService(environment, vaultAccessToken) {
    _classCallCheck(this, OrganizationsService);

    // for mocking during testing
    this.cryppo = global.cryppo || _cryppo;
    this.api = vaultAPIFactory(environment)(vaultAccessToken).OrganizationsManagingOrganizationsApi;
  }

  _createClass(OrganizationsService, [{
    key: "getLogin",
    value: function getLogin(id, privateKey) {
      try {
        var _this2 = this;

        return _await$6(_this2.api.organizationsIdLoginPost(id), function (result) {
          return _await$6(_this2.cryppo.decryptSerializedWithPrivateKey({
            privateKeyPem: privateKey,
            serialized: result.encrypted_access_token
          }), function (decryptedVaultSessionToken) {
            return new AuthData({
              secret: '',
              keystore_access_token: '',
              vault_access_token: decryptedVaultSessionToken,
              data_encryption_key: EncryptionKey.fromRaw(''),
              key_encryption_key: EncryptionKey.fromRaw(''),
              passphrase_derived_key: EncryptionKey.fromRaw('')
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "create",
    value: function create(organization) {
      try {
        var _this4 = this;

        return _await$6(_this4.cryppo.generateRSAKeyPair(4096), function (rsaKeyPair) {
          organization.public_key = rsaKeyPair.publicKey;
          return _await$6(_this4.api.organizationsPost(organization), function (result) {
            return {
              organization: result.organization,
              privateKey: rsaKeyPair.privateKey,
              publicKey: rsaKeyPair.publicKey
            };
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);

  return OrganizationsService;
}();

function _await$7(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

// tslint:disable-next-line: no-var-requires
var baseX = require('base-x');
/**
 * Used for dealing with Meeco secrets - used for user authentication and login
 */

var SecretService = /*#__PURE__*/function () {
  function SecretService() {
    _classCallCheck(this, SecretService);

    this.derivationConstants = {
      iterationVariance: 0,
      minIterations: 100000,
      length: 32
    };
  }
  /**
   * Pluck the SRP Username from a users' secret
   */


  _createClass(SecretService, [{
    key: "usernameFromSecret",
    value: function usernameFromSecret(secret) {
      var _this$destructureSecr = this.destructureSecret(secret),
          username = _this$destructureSecr.username;

      return username;
    }
    /**
     * Given a user's Secret and Passphrase - derive the Passphrase Derived Key (used to decrypt their Key Encryption Key)
     */

  }, {
    key: "derivePDKFromSecret",
    value: function derivePDKFromSecret(userEnteredPassword, secret) {
      var _this$destructureSecr2 = this.destructureSecret(secret),
          secretKey = _this$destructureSecr2.secretKey;

      return this.derivePDK(userEnteredPassword, secretKey);
    }
  }, {
    key: "srpPasswordFromSecret",
    value: function srpPasswordFromSecret(userEnteredPassword, secret) {
      var _this$destructureSecr3 = this.destructureSecret(secret),
          secretKey = _this$destructureSecr3.secretKey;

      return this.deriveSRPPasswordFromSecretKey(userEnteredPassword, secretKey);
    }
    /**
     * Generate a new user Secret from the provided username.
     * Usernames can be requested via the {@link UserService}
     */

  }, {
    key: "generateSecret",
    value: function generateSecret(username) {
      try {
        var _this2 = this;

        return _await$7(_cryppo.generateRandomKey(32), function (key) {
          var secretKey = _this2.encodeBase58(key);

          var version = 1;
          var readable = secretKey.match(/(.{1,6})/g).join('-');
          return "".concat(version, ".").concat(username, ".").concat(readable);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Public for testing purposes only.
     *
     * @ignore
     */

  }, {
    key: "encodeBase58",
    value: function encodeBase58(val) {
      // https://tools.ietf.org/html/draft-msporny-base58-01
      var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      var input = val instanceof Buffer ? val : Buffer.from(val, 'binary');
      return baseX(ALPHABET).encode(input);
    }
    /**
     * Separate out a user's secret into its component parts
     */

  }, {
    key: "destructureSecret",
    value: function destructureSecret(secret) {
      var _secret$split = secret.split('.'),
          _secret$split2 = _slicedToArray(_secret$split, 3),
          version = _secret$split2[0],
          username = _secret$split2[1],
          secretKey = _secret$split2[2];

      if (!version || !username || !secretKey) {
        throw new MeecoServiceError('Invalid secret format', ERROR_CODES.InvalidSecretFormat);
      }

      return {
        version: version,
        username: username,
        secretKey: secretKey.replace(/-/g, '') // strip padding from secret key

      };
    }
  }, {
    key: "deriveSRPPasswordFromSecretKey",
    value: function deriveSRPPasswordFromSecretKey(password, secretKey) {
      if (secretKey.indexOf('.') >= 0) {
        throw new Error('Incorrect secret provided. Please destructure the secret_key.');
      }

      return _cryppo.generateDerivedKey(Object.assign(Object.assign({}, this.derivationConstants), {
        key: password,
        useSalt: secretKey.split('').reverse().join('')
      })).then(function (derived) {
        return derived.key;
      });
    }
  }, {
    key: "derivePDK",
    value: function derivePDK(password, secretKey) {
      if (secretKey.indexOf('.') >= 0) {
        throw new Error('Incorrect secret provided. Please destructure the secret_key.');
      }

      return _cryppo.generateDerivedKey(Object.assign(Object.assign({}, this.derivationConstants), {
        key: password,
        useSalt: secretKey
      })).then(function (derived) {
        return derived.key;
      });
    }
  }]);

  return SecretService;
}();

var EncryptionSpaceData = /*#__PURE__*/function () {
  function EncryptionSpaceData(config) {
    _classCallCheck(this, EncryptionSpaceData);

    this.from_user_connection_id = config.from_user_connection_id;
    this.to_user_connection_id = config.to_user_connection_id;
    this.shared_data_encryption_key = config.shared_data_encryption_key;
  }

  _createClass(EncryptionSpaceData, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        kind: EncryptionSpaceData.kind,
        spec: {
          to_user_connection_id: this.to_user_connection_id,
          from_user_connection_id: this.from_user_connection_id,
          shared_data_encryption_key: this.shared_data_encryption_key
        }
      };
    }
  }]);

  return EncryptionSpaceData;
}();
EncryptionSpaceData.kind = 'EncryptionSpace';

/**
 * Service for sharing data between two connected Meeco users.
 * Connections can be setup via the {@link ConnectionService}
 */

function _await$8(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}
/**
 * @visibleForTesting
 * @ignore
 */


function _invoke$1(body, then) {
  var result = body();

  if (result && result.then) {
    return result.then(then);
  }

  return then(result);
}

function _async$3(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

var ShareService = /*#__PURE__*/function () {
  function ShareService(environment) {
    var log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

    _classCallCheck(this, ShareService);

    this.environment = environment;
    this.log = log; // for mocking during testing

    this.cryppo = global.cryppo || _cryppo;
    this.keystoreApiFactory = keystoreAPIFactory(environment);
    this.vaultApiFactory = vaultAPIFactory(environment);
  }

  _createClass(ShareService, [{
    key: "shareItem",
    value: function shareItem(fromUser, connectionId, itemId) {
      var shareOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      try {
        var _this2 = this;

        return _await$8(fetchConnectionWithId(fromUser, connectionId, _this2.environment, _this2.log), function (fromUserConnection) {
          _this2.log('Fetching shared encryption space');

          return _await$8(_this2.fetchSharedEncryptionSpace(fromUser, fromUserConnection), function (sharedEncryptionSpace) {
            return _await$8(_this2.shareItemFromVaultItem(fromUser, fromUserConnection, sharedEncryptionSpace, itemId, fromUserConnection.user_id, shareOptions), function (share) {
              _this2.log('Sending shared data');

              return _await$8(_this2.vaultApiFactory(fromUser).SharesApi.sharesPost({
                shares: [share]
              }), function (shareResult) {
                return Object.assign(Object.assign({}, share), {
                  share: shareResult
                });
              });
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "listShares",
    value: function listShares(user) {
      try {
        var _this4 = this;

        return _await$8(_this4.vaultApiFactory(user).SharesApi.sharesIncomingGet());
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "deleteSharedItem",
    value: function deleteSharedItem(user, shareId) {
      try {
        var _this6 = this;

        return _await$8(_this6.vaultApiFactory(user).SharesApi.sharesIdDelete(shareId)["catch"](function (err) {
          if (err.status === 404) {
            throw new MeecoServiceError("Share with id '".concat(shareId, "' not found for the specified user"));
          }

          throw err;
        }), function () {
          _this6.log('Share successfully deleted');
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "getSharedItem",
    value: function getSharedItem(user, shareId) {
      try {
        var _this8 = this;

        return _await$8(_this8.vaultApiFactory(user).SharesApi.sharesIdGet(shareId)["catch"](function (err) {
          if (err.status === 404) {
            throw new MeecoServiceError("Share with id '".concat(shareId, "' not found for the specified user"));
          }

          throw err;
        }), function (result) {
          var item = result.item,
              share = result.share;
          return _await$8(_this8.ensureClaimedKey(user, share.connection_id), function (connection) {
            var slots = result.slots;
            return _await$8(_this8.keystoreApiFactory(user).EncryptionSpaceApi.encryptionSpacesIdGet(connection.encryption_space_id), function (space) {
              return _await$8(_this8.cryppo.decryptWithKey({
                serialized: space.encryption_space_data_encryption_key.serialized_data_encryption_key,
                key: user.key_encryption_key.key
              }), function (decryptedSharedDataEncryptionKey) {
                var key = EncryptionKey.fromRaw(decryptedSharedDataEncryptionKey);
                return _await$8(ItemService.decryptAllSlots(slots, key), function (decryptedSlots) {
                  return {
                    item: item,
                    slots: decryptedSlots,
                    share: share,
                    connection: connection
                  };
                });
              });
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "shareItemFromVaultItem",
    value: function shareItemFromVaultItem(fromUser, connection, sharedEncryptionSpace, itemId, toUserId, shareOptions) {
      try {
        var _this10 = this;

        return _await$8(_this10.vaultApiFactory(fromUser).ItemApi.itemsIdGet(itemId), function (item) {
          if (!item) {
            throw new MeecoServiceError("Item '".concat(itemId, "' not found"));
          }

          var slots = item.slots;
          return _invoke$1(function () {
            if (!sharedEncryptionSpace.shared_data_encryption_key) {
              _this10.log('No encryption space found - creating one');

              return _await$8(_this10.createSharedEncryptionSpace(fromUser, connection), function (encryptonSpace) {
                sharedEncryptionSpace = {
                  from_user_connection_id: connection.id,
                  shared_data_encryption_key: EncryptionKey.fromRaw(encryptonSpace.dataEncryptionKey)
                };
              });
            }
          }, function () {
            _this10.log('Decrypting all slots');

            return _await$8(ItemService.decryptAllSlots(slots, fromUser.data_encryption_key), function (decryptedSlots) {
              _this10.log('Encrypting slots with shared key');

              return _await$8(_this10.convertSlotsToEncryptedValuesForShare(decryptedSlots, sharedEncryptionSpace.shared_data_encryption_key), function (encrypted_values) {
                return Object.assign(Object.assign({}, shareOptions), {
                  shareable_id: itemId,
                  shareable_type: 'Item',
                  encrypted_values: encrypted_values,
                  distributable: false,
                  outgoing: true,
                  // TODO - this should be the connection id but API does not support it yet
                  user_id: toUserId
                });
              });
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "fetchSharedEncryptionSpace",
    value: function fetchSharedEncryptionSpace(user, connection) {
      try {
        var _this12 = this;

        var _a;

        if (!connection.encryption_space_id) {
          // Users have no shared encryption space
          return new EncryptionSpaceData({
            from_user_connection_id: connection.id
          });
        }

        _this12.log('Fetching shared encryption key');

        return _await$8(_this12.keystoreApiFactory(user).EncryptionSpaceApi.encryptionSpacesIdGet(connection.encryption_space_id), function (sharedDataEncryptionKey) {
          return _await$8(_this12.cryppo.decryptWithKey({
            serialized: (_a = sharedDataEncryptionKey.encryption_space_data_encryption_key) === null || _a === void 0 ? void 0 : _a.serialized_data_encryption_key,
            key: user.key_encryption_key.key
          }), function (decryptedSharedDataEncryptionKey) {
            return new EncryptionSpaceData({
              from_user_connection_id: connection.id,
              shared_data_encryption_key: EncryptionKey.fromRaw(decryptedSharedDataEncryptionKey)
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "createSharedEncryptionSpace",
    value: function createSharedEncryptionSpace(fromUser, connection) {
      try {
        var _this14 = this;

        var _a;

        _this14.log('Generating from user data encryption key');

        return _await$8(_this14.createAndStoreNewDataEncryptionKey(fromUser), function (fromUserEncryptionSpace) {
          var encryptionSpaceId = (_a = fromUserEncryptionSpace.encryptionSpace) === null || _a === void 0 ? void 0 : _a.encryption_space_id;
          var recipientPublicKey = connection.other_user_connection_public_key;

          if (!recipientPublicKey) {
            throw new MeecoServiceError('Other user public key missing!');
          }

          return _await$8(_this14.cryppo.encryptWithPublicKey({
            data: fromUserEncryptionSpace.dataEncryptionKey,
            publicKeyPem: recipientPublicKey
          }), function (shareableDataEncryptionKey) {
            _this14.log('Updating connection encryption space');

            return _await$8(_this14.vaultApiFactory(fromUser).ConnectionApi.connectionsConnectionIdEncryptionSpacePost(connection.id, {
              encryption_space_id: encryptionSpaceId
            }), function () {
              _this14.log('Sending shared key');

              return _await$8(_this14.keystoreApiFactory(fromUser).SharedKeyApi.sharedKeysPost({
                encrypted_key: shareableDataEncryptionKey.serialized,
                external_id: encryptionSpaceId,
                public_key: recipientPublicKey,
                key_metadata: {
                  key_type: _this14.cryppo.CipherStrategy.AES_GCM
                }
              }), function (sharedKey) {
                return {
                  connection: connection,
                  dataEncryptionKey: fromUserEncryptionSpace.dataEncryptionKey,
                  fromUserSharedKey: sharedKey.shared_key
                };
              });
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "ensureClaimedKey",
    value: function ensureClaimedKey(user, connectionId) {
      try {
        var _this16 = this;

        return _await$8(fetchConnectionWithId(user, connectionId, _this16.environment, _this16.log), function (connection) {
          if (!connection.encryption_space_id) {
            _this16.log('Shared data encryption key not yet claimed - claiming');

            return _this16.claimSharedEncryptionSpace(user, connection);
          }

          return connection;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "claimSharedEncryptionSpace",
    value: function claimSharedEncryptionSpace(toUser, connection) {
      try {
        var _this18 = this;

        var encryptionSpaceId = connection.other_user_connection_encryption_space_id;

        _this18.log('Fetching key pair');

        return _await$8(_this18.keystoreApiFactory(toUser).KeypairApi.keypairsIdGet(connection.keypair_external_id).then(function (res) {
          return res.keypair;
        }), function (keyPair) {
          return _await$8(_this18.cryppo.decryptWithKey({
            serialized: keyPair.encrypted_serialized_key,
            key: toUser.key_encryption_key.key
          }), function (privateKey) {
            _this18.log('Claiming data encryption key');

            return _await$8(_this18.claimAndReEncryptSharedDataEncryptionKey(toUser, encryptionSpaceId, {
              publicKey: keyPair.public_key,
              privateKey: privateKey
            }), function (reEncryptedDataEncryptionKey) {
              _this18.log('Creating new encryption space with re-encrypted claimed key');

              return _await$8(_this18.keystoreApiFactory(toUser).EncryptionSpaceApi.encryptionSpacesPost({
                encrypted_serialized_key: reEncryptedDataEncryptionKey.serialized
              }), function (encryptionSpace) {
                var encryption_space_id = encryptionSpace.encryption_space_data_encryption_key.encryption_space_id;

                _this18.log('Updating shared encryption space');

                return _await$8(_this18.vaultApiFactory(toUser).ConnectionApi.connectionsConnectionIdEncryptionSpacePost(connection.id, {
                  encryption_space_id: encryption_space_id
                }), function () {
                  connection.encryption_space_id = encryption_space_id;
                  return connection;
                });
              });
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "createAndStoreNewDataEncryptionKey",
    value: function createAndStoreNewDataEncryptionKey(user) {
      try {
        var _this20 = this;

        var dataEncryptionKey = _this20.cryppo.generateRandomKey();

        return _await$8(_this20.cryppo.encryptWithKey({
          data: dataEncryptionKey,
          key: user.key_encryption_key.key,
          strategy: _this20.cryppo.CipherStrategy.AES_GCM
        }), function (encryptedDataEncryptionKey) {
          return _await$8(_this20.keystoreApiFactory(user).EncryptionSpaceApi.encryptionSpacesPost({
            encrypted_serialized_key: encryptedDataEncryptionKey.serialized
          }).then(function (result) {
            return result.encryption_space_data_encryption_key;
          }), function (encryptionSpace) {
            return {
              dataEncryptionKey: dataEncryptionKey,
              encryptionSpace: encryptionSpace
            };
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "claimAndReEncryptSharedDataEncryptionKey",
    value: function claimAndReEncryptSharedDataEncryptionKey(user, encryptionSpaceId, keyPair) {
      try {
        var _this22 = this;

        var _a;

        return _await$8(_this22.buildClaimKeySignature(encryptionSpaceId, keyPair.privateKey), function (signature) {
          return _await$8(_this22.keystoreApiFactory(user).SharedKeyApi.sharedKeysExternalIdClaimKeyPost(encryptionSpaceId, {
            public_key: keyPair.publicKey,
            request_signature: signature.serialized
          })["catch"](_async$3(function (err) {
            var _exit = false;
            return _invoke$1(function () {
              if ((err === null || err === void 0 ? void 0 : err.status) === 403 && typeof (err === null || err === void 0 ? void 0 : err.json) === 'function') {
                return _await$8(err.json(), function (json) {
                  if ((json === null || json === void 0 ? void 0 : json.errors[0].error) === 'invalid_request_signature') {
                    throw new MeecoServiceError("Failed to claim shared encryption key - the request signature was rejected by the API");
                  }
                });
              }
            }, function (_result) {
              if (_exit) return _result;
              throw err;
            });
          })), function (claimedKey) {
            return _await$8(_this22.cryppo.decryptSerializedWithPrivateKey({
              serialized: (_a = claimedKey.shared_key_claimed) === null || _a === void 0 ? void 0 : _a.serialized_shared_key,
              privateKeyPem: keyPair.privateKey
            }), function (decryptedDataEncryptionKey) {
              return _await$8(_this22.cryppo.encryptWithKey({
                key: user.key_encryption_key.key,
                data: decryptedDataEncryptionKey,
                strategy: _this22.cryppo.CipherStrategy.AES_GCM
              }));
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "buildClaimKeySignature",
    value: function buildClaimKeySignature(encryptionSpaceId, privateKey) {
      var requestUrl = "".concat(this.environment.keystore.url, "/shared_keys/").concat(encryptionSpaceId, "/claim_key");
      var verification = "--request-timestamp=".concat(new ShareService.Date().toISOString());
      var urlToSign = requestUrl + verification;
      return this.cryppo.signWithPrivateKey(privateKey, urlToSign);
    }
    /**
     * In the API: a share expects an `encrypted_value` property.
     * For a tile item - this is a stringified json payload of key/value
     * pairs where the key is the slot id and the value is the slot value
     * encrypted with a shared data encryption key.
     */

  }, {
    key: "convertSlotsToEncryptedValuesForShare",
    value: function convertSlotsToEncryptedValuesForShare(slots, sharedDataEncryptionKey) {
      try {
        var _this24 = this;

        var encryptions = slots.filter(function (slot) {
          return slot.value;
        }).map(_async$3(function (slot) {
          return _await$8(_cryppo.encryptWithKey({
            data: slot.value || '',
            key: sharedDataEncryptionKey.key,
            strategy: _this24.cryppo.CipherStrategy.AES_GCM
          }).then(function (result) {
            return result.serialized;
          }), function (encrypted_value) {
            return {
              slot_id: slot.id,
              encrypted_value: encrypted_value
            };
          });
        }));
        return Promise.all(encryptions);
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);

  return ShareService;
}();
ShareService.Date = global.Date;

/**
 * List and fetch available templates for Meeco Items from the API.
 *
 * @deprecated Use [vaultApiFactory] ItemTemplateApi list instead.
 */

function _await$9(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

var TemplatesService = /*#__PURE__*/function () {
  function TemplatesService(environment, vaultAccessToken) {
    _classCallCheck(this, TemplatesService);

    this.api = vaultAPIFactory(environment)(vaultAccessToken).ItemTemplateApi;
  }

  _createClass(TemplatesService, [{
    key: "listTemplates",
    value: function listTemplates(classificationScheme, classificationName) {
      try {
        var _this2 = this;

        return _await$9(_this2.api.itemTemplatesGet(classificationScheme, classificationName));
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * @deprecated Use [vaultApiFactory] ItemTemplateApi list or get by id instead.
     */

  }, {
    key: "getTemplate",
    value: function getTemplate(classificationScheme, classificationName, name) {
      try {
        var _this4 = this;

        var _a, _b;

        return _await$9(_this4.api.itemTemplatesGet(classificationScheme, classificationName), function (result) {
          var template = (_a = result.item_templates) === null || _a === void 0 ? void 0 : _a.find(function (_template) {
            return _template.name === name;
          });

          if (!template) {
            throw new MeecoServiceError("Template '".concat(name, "' not found of classification name '").concat(classificationName, "' and scheme ").concat(classificationScheme));
          }

          var slots = (_b = result.slots) === null || _b === void 0 ? void 0 : _b.filter(function (slot) {
            var _a;

            return (_a = template.slot_ids) === null || _a === void 0 ? void 0 : _a.includes(slot.id);
          });
          var classification_nodes = result.classification_nodes.filter(function (classificationNode) {
            return template.classification_node_ids.includes(classificationNode.id);
          });
          return {
            template: template,
            slots: slots,
            classification_nodes: classification_nodes
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);

  return TemplatesService;
}();

/**
 * Create and update Meeco Users.
 */

function _await$a(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
} // This should be more like `auth:my-user:api-sandbox.meeco.me` but the api does not support it


function _empty$2() {}

function _awaitIgnored$1(value, direct) {
  if (!direct) {
    return value && value.then ? value.then(_empty$2) : Promise.resolve();
  }
}

var UserService = /*#__PURE__*/function () {
  function UserService(environment) {
    var log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (msg) {};

    _classCallCheck(this, UserService);

    this.log = log; // for mocking during testing

    this.cryppo = global.cryppo || _cryppo;
    this.keystoreApiFactory = keystoreAPIFactory(environment);
    this.vaultApiFactory = vaultAPIFactory(environment);
    this.vaultKeypairExternalId = UserService.VAULT_PAIR_EXTERNAL_IDENTIFIER;
    this.keyGen = new SecretService();
  }

  _createClass(UserService, [{
    key: "requestKeyPair",
    value: function requestKeyPair(keystoreSessionToken) {
      var vaultUserApi = this.keystoreApiFactory(keystoreSessionToken).KeypairApi;
      return vaultUserApi.keypairsExternalIdExternalIdGet(this.vaultKeypairExternalId).then(function (res) {
        return res.keypair;
      });
    }
  }, {
    key: "requestExternalAdmissionTokens",
    value: function requestExternalAdmissionTokens(sessionAuthenticationToken) {
      var keystoreExternalAdmissionApi = this.keystoreApiFactory(sessionAuthenticationToken).ExternalAdmissionTokensApi;
      this.log('Request external admission tokens from keystore');
      return keystoreExternalAdmissionApi.externalAdmissionTokensGet().then(function (res) {
        return res.external_admission_token;
      });
    }
  }, {
    key: "generateAndStoreKeyEncryptionKey",
    value: function generateAndStoreKeyEncryptionKey(derivedKey, sessionAuthentication) {
      try {
        var _this2 = this;

        _this2.log('Generate and store key encryption key');

        var kek = _this2.cryppo.generateRandomKey();

        return _await$a(_this2.cryppo.encryptWithKey({
          strategy: _this2.cryppo.CipherStrategy.AES_GCM,
          key: derivedKey,
          data: kek
        }), function (encryptedKEK) {
          var keystoreKeyEncryptionKeyApi = _this2.keystoreApiFactory(sessionAuthentication).KeyEncryptionKeyApi;

          return _await$a(keystoreKeyEncryptionKeyApi.keyEncryptionKeyPost({
            serialized_key_encryption_key: encryptedKEK.serialized
          }), function () {
            return kek;
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "getKeyEncryptionKey",
    value: function getKeyEncryptionKey(sessionAuthentication) {
      this.log('Requesting key encryption key');
      var keystoreKeyEncryptionKeyApi = this.keystoreApiFactory(sessionAuthentication).KeyEncryptionKeyApi;
      return keystoreKeyEncryptionKeyApi.keyEncryptionKeyGet().then(function (result) {
        return result.key_encryption_key;
      });
    }
  }, {
    key: "generateAndStoreDataEncryptionKey",
    value: function generateAndStoreDataEncryptionKey(keyEncryptionKey, sessionAuthentication) {
      try {
        var _this4 = this;

        _this4.log('Generate and store data encryption key');

        var dek = _this4.cryppo.generateRandomKey();

        return _await$a(_this4.cryppo.encryptWithKey({
          data: dek,
          key: keyEncryptionKey,
          strategy: _this4.cryppo.CipherStrategy.AES_GCM
        }), function (dekEncryptedWithKEK) {
          var keystoreDataEncryptionKeyApi = _this4.keystoreApiFactory(sessionAuthentication).DataEncryptionKeyApi;

          return _await$a(keystoreDataEncryptionKeyApi.dataEncryptionKeysPost({
            serialized_data_encryption_key: dekEncryptedWithKEK.serialized
          }), function (stored) {
            return {
              key: dek,
              serializedEncrypted: dekEncryptedWithKEK.serialized,
              id: stored.data_encryption_key.id
            };
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "getDataEncryptionKey",
    value: function getDataEncryptionKey(sessionAuthentication, encryptionSpaceId) {
      this.log('Requesting data encryption key');
      var keystoreDataEncryptionKeyApi = this.keystoreApiFactory(sessionAuthentication).DataEncryptionKeyApi;
      return keystoreDataEncryptionKeyApi.dataEncryptionKeysIdGet(encryptionSpaceId).then(function (result) {
        return result.data_encryption_key;
      });
    }
  }, {
    key: "generateAndStoreVaultKeyPair",
    value: function generateAndStoreVaultKeyPair(keyEncryptionKey, sessionAuthentication) {
      try {
        var _this6 = this;

        _this6.log('Generate and store vault key pair');

        return _await$a(_this6.cryppo.generateRSAKeyPair(), function (keyPair) {
          var keystoreKeypairApi = _this6.keystoreApiFactory(sessionAuthentication).KeypairApi;

          return _await$a(_this6.cryppo.encryptWithKey({
            data: keyPair.privateKey,
            key: keyEncryptionKey,
            strategy: _this6.cryppo.CipherStrategy.AES_GCM
          }), function (privateKeyEncryptedWithKEK) {
            return _await$a(keystoreKeypairApi.keypairsPost({
              public_key: keyPair.publicKey,
              encrypted_serialized_key: privateKeyEncryptedWithKEK.serialized,
              external_identifiers: [_this6.vaultKeypairExternalId]
            }), function () {
              return keyPair;
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "createNewVaultUser",
    value: function createNewVaultUser(keyPair, vaultAdmissionToken) {
      try {
        var _this8 = this;

        _this8.log('Create vault api user'); // No key required as we're only registering a new user


        var vaultUserApi = _this8.vaultApiFactory('').UserApi;

        return _await$a(vaultUserApi.mePost({
          public_key: keyPair.publicKey,
          admission_token: vaultAdmissionToken
        }), function (vaultUser) {
          return _await$a(_this8.cryppo.decryptSerializedWithPrivateKey({
            privateKeyPem: keyPair.privateKey,
            serialized: vaultUser.encrypted_session_authentication_string
          }), function (decryptedVaultSessionToken) {
            return {
              user: vaultUser.user,
              token: decryptedVaultSessionToken
            };
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "getVaultSession",
    value: function getVaultSession(keyPair) {
      try {
        var _this10 = this;

        // No auth key required as we're only logging in
        var sessionApi = _this10.vaultApiFactory('').SessionApi;

        return _await$a(sessionApi.sessionPost({
          public_key: keyPair.publicKey
        }).then(function (result) {
          return result.session;
        }), function (session) {
          return _await$a(_this10.cryppo.decryptSerializedWithPrivateKey({
            privateKeyPem: keyPair.privateKey,
            serialized: session.encrypted_session_authentication_string
          }), function (decryptedVaultSessionToken) {
            return _await$a(_this10.getVaultUser(decryptedVaultSessionToken), function (userResponse) {
              return {
                user: userResponse.user,
                token: decryptedVaultSessionToken
              };
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "createPrivateEncryptionSpaceForUser",
    value: function createPrivateEncryptionSpaceForUser(keyEncryptionKey, keystoreSessionToken, vaultSessionToken) {
      try {
        var _this12 = this;

        var vaultUserApi = _this12.vaultApiFactory(vaultSessionToken).UserApi;

        return _await$a(_this12.generateAndStoreDataEncryptionKey(keyEncryptionKey, keystoreSessionToken), function (dek) {
          _this12.log('Update vault encryption space');

          return _await$a(vaultUserApi.mePut({
            user: {
              private_encryption_space_id: dek.id
            }
          }), function () {
            return dek;
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Request a new random username from the Keystore API to use for user creation
     */

  }, {
    key: "generateUsername",
    value: function generateUsername(captcha_token) {
      try {
        var _this14 = this;

        _this14.log('Generating username');

        return _this14.keystoreApiFactory('').UserApi.srpUsernamePost({
          captcha_token: captcha_token
        }).then(function (res) {
          return res.username;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Usernames for secrets can be generated via {@link generateUsername}
     */

  }, {
    key: "create",
    value: function create(userPassword, secret) {
      try {
        var _this16 = this;

        return _await$a(_this16.registerKeystoreViaSRP(userPassword, secret), function () {
          return _await$a(_this16.loginKeystoreViaSRP(userPassword, secret), function (sessionAuthenticationToken) {
            return _await$a(_this16.requestExternalAdmissionTokens(sessionAuthenticationToken), function (_ref) {
              var vault_api_admission_token = _ref.vault_api_admission_token;
              return _await$a(_this16.keyGen.derivePDKFromSecret(userPassword, secret), function (derivedKey) {
                return _await$a(_this16.generateAndStoreKeyEncryptionKey(derivedKey, sessionAuthenticationToken), function (kek) {
                  return _await$a(_this16.generateAndStoreVaultKeyPair(kek, sessionAuthenticationToken), function (keyPair) {
                    return _await$a(_this16.createNewVaultUser(keyPair, vault_api_admission_token), function (vaultUser) {
                      return _await$a(_this16.createPrivateEncryptionSpaceForUser(kek, sessionAuthenticationToken, vaultUser.token), function (privateEncryptionSpace) {
                        return new AuthData({
                          secret: secret,
                          keystore_access_token: sessionAuthenticationToken,
                          vault_access_token: vaultUser.token,
                          data_encryption_key: EncryptionKey.fromRaw(privateEncryptionSpace.key),
                          key_encryption_key: EncryptionKey.fromRaw(kek),
                          passphrase_derived_key: EncryptionKey.fromRaw(derivedKey)
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "registerKeystoreViaSRP",
    value: function registerKeystoreViaSRP(userPassword, secret) {
      try {
        var _this18 = this;

        _this18.log('Initializing SRP');

        var username = _this18.keyGen.usernameFromSecret(secret);

        return _await$a(_this18.keyGen.srpPasswordFromSecret(userPassword, secret), function (srpPassword) {
          return _await$a(new SRPSession().init(username, srpPassword), function (srpSession) {
            return _await$a(srpSession.createVerifier(), function (verifier) {
              _this18.log('Create SRP keystore user');

              return _awaitIgnored$1(_this18.keystoreApiFactory('').UserApi.srpUsersPost({
                username: username,
                srp_salt: verifier.salt,
                srp_verifier: verifier.verifier
              })["catch"](function (err) {
                if (err.status === 400) {
                  return err.json().then(function (result) {
                    var _a;

                    if (((_a = result.errors[0]) === null || _a === void 0 ? void 0 : _a.error) === 'username_taken') {// User exists - can continue on to try login instead
                    } else {
                      throw err;
                    }
                  });
                } else {
                  throw err;
                }
              }));
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "loginKeystoreViaSRP",
    value: function loginKeystoreViaSRP(userPassword, secret) {
      try {
        var _this20 = this;

        var username = _this20.keyGen.usernameFromSecret(secret);

        _this20.log('Starting SRP login');

        return _await$a(_this20.keyGen.srpPasswordFromSecret(userPassword, secret), function (password) {
          return _await$a(new SRPSession().init(username, password), function (srpSession) {
            return _await$a(srpSession.getClientPublic(), function (srp_a) {
              _this20.log('Requesting SRP challenge from server');

              return _await$a(_this20.keystoreApiFactory('').UserApi.srpChallengesPost({
                srp_a: srp_a,
                username: username
              }).then(function (result) {
                return result.challenge;
              }), function (challenge) {
                return _await$a(srpSession.computeProofFromChallenge({
                  salt: challenge.challenge_salt,
                  serverPublic: challenge.challenge_b
                }), function (srp_m) {
                  _this20.log('Creating SRP session with proof');

                  return _this20.keystoreApiFactory('').SessionApi.srpSessionPost({
                    username: username,
                    srp_a: srp_a,
                    srp_m: srp_m
                  }).then(function (res) {
                    return res.session.session_authentication_string;
                  })["catch"](function (err) {
                    if (err.status === 401) {
                      throw new MeecoServiceError('Login failed - please check details', ERROR_CODES.LoginFailed);
                    }

                    throw err;
                  });
                });
              });
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Given a user's passphrase and secret - fetch all data required to interact with Meeco's APIs on their behalf such as encryption keys
     */

  }, {
    key: "get",
    value: function get(userPassword, secret) {
      try {
        var _this22 = this;

        _this22.log('Deriving keys');

        return _await$a(_this22.keyGen.derivePDKFromSecret(userPassword, secret), function (derivedKey) {
          return _await$a(_this22.loginKeystoreViaSRP(userPassword, secret), function (sessionAuthenticationToken) {
            return _await$a(_this22.getKeyEncryptionKey(sessionAuthenticationToken), function (encryptedKek) {
              return _await$a(_this22.cryppo.decryptWithKey({
                serialized: encryptedKek.serialized_key_encryption_key,
                key: derivedKey
              }), function (kek) {
                return _await$a(_this22.requestKeyPair(sessionAuthenticationToken), function (keyPair) {
                  return _await$a(_this22.cryppo.decryptWithKey({
                    serialized: keyPair.encrypted_serialized_key,
                    key: kek
                  }), function (decryptedPrivateKey) {
                    return _await$a(_this22.getVaultSession({
                      privateKey: decryptedPrivateKey,
                      publicKey: keyPair.public_key
                    }), function (vaultUser) {
                      return _await$a(_this22.getDataEncryptionKey(sessionAuthenticationToken, vaultUser.user.private_encryption_space_id), function (encryptedDek) {
                        return _await$a(_this22.cryppo.decryptWithKey({
                          serialized: encryptedDek.serialized_data_encryption_key,
                          key: kek
                        }), function (dek) {
                          return new AuthData({
                            secret: secret,
                            keystore_access_token: sessionAuthenticationToken,
                            vault_access_token: vaultUser.token,
                            data_encryption_key: EncryptionKey.fromRaw(dek),
                            key_encryption_key: EncryptionKey.fromRaw(kek),
                            passphrase_derived_key: EncryptionKey.fromRaw(derivedKey)
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "getVaultUser",
    value: function getVaultUser(vaultAccessToken) {
      return this.vaultApiFactory(vaultAccessToken).UserApi.meGet();
    }
  }]);

  return UserService;
}();
UserService.VAULT_PAIR_EXTERNAL_IDENTIFIER = 'auth';

/**
 * The publicly exposed API
 */
var _cryppoService = _cryppo;

exports.AuthData = AuthData;
exports.ClientTaskQueueService = ClientTaskQueueService;
exports.ConnectionCreateData = ConnectionCreateData;
exports.ConnectionService = ConnectionService;
exports.ERROR_CODES = ERROR_CODES;
exports.EncryptionKey = EncryptionKey;
exports.Environment = Environment;
exports.FileAttachmentData = FileAttachmentData;
exports.ItemCreateData = ItemCreateData;
exports.ItemService = ItemService;
exports.ItemUpdateData = ItemUpdateData;
exports.MeecoServiceError = MeecoServiceError;
exports.OrganizationServicesService = OrganizationServicesService;
exports.OrganizationsService = OrganizationsService;
exports.SRPSession = SRPSession;
exports.SecretService = SecretService;
exports.ShareService = ShareService;
exports.TemplatesService = TemplatesService;
exports.UserService = UserService;
exports._cryppoService = _cryppoService;
exports.configureFetch = configureFetch;
exports.fetchConnectionWithId = fetchConnectionWithId;
exports.findConnectionBetween = findConnectionBetween;
exports.keystoreAPIFactory = keystoreAPIFactory;
exports.vaultAPIFactory = vaultAPIFactory;
