import * as Keystore from '@meeco/keystore-api-sdk';
import * as Vault from '@meeco/vault-api-sdk';
import { AuthData } from '../models/auth-data';
import { Environment } from '../models/environment';
/**
 * Configure the fetch library to use for API requests
 */
export declare const configureFetch: (_fetch: any) => any;
/**
 * User authentication token for the given API or the entire user with tokens
 */
declare type UserAuth = AuthData | string;
declare type KeystoreAPIConstructor = new () => Keystore.BaseAPI;
declare type VaultAPIConstructor = new () => Vault.BaseAPI;
declare type KeysOfType<T, TProp> = {
    [P in keyof T]: T[P] extends TProp ? P : never;
}[keyof T];
declare type VaultAPIName = KeysOfType<typeof Vault, VaultAPIConstructor>;
declare type KeystoreAPIName = KeysOfType<typeof Keystore, KeystoreAPIConstructor>;
interface IHeaders {
    [key: string]: string;
}
/**
 * Convenience for the various headers and parameters that need to be setup when constructing an API.
 *
 * It avoids a lot of boilerplate in constructing arguments for an api (api keys, subscription keys etc.)
 *
 * Basically, instead of
 * ```ts
 * new Keystore.EncryptionSpaceApi({
 *  baseApi: environment.api.url,
 *   apiKey: (key: string) => {
 *    if(key === 'Meeco-Subscription-Key') return environment.keystore.subscription_key;
 *    if(key === 'Authorization) return user.keystore_access_token
 *   }
 * }).someMethod();
 * ```
 *
 * you can create a factory that returns these instances for you:
 *
 * ```ts
 * const factory = keystoreAPIFactory(environment);
 * const forUser = factory(userAuth);
 * forUser.EncryptionSpaceApi.getItems();
 * forUser.KeypairApi.getConnections();
 * // etc...
 * ```
 */
export declare type KeystoreAPIFactory = (userAuth: UserAuth, headers?: IHeaders) => KeystoreAPIFactoryInstance;
export declare type KeystoreAPIFactoryInstance = {
    [key in KeystoreAPIName]: InstanceType<typeof Keystore[key]>;
};
/**
 * Convenience for the various headers and parameters that need to be setup when constructing an API.
 *
 * It avoids a lot of boilerplate in constructing arguments for an api (api keys, subscription keys etc.)
 *
 * Basically, instead of
 * ```ts
 * new Vault.ItemApi({
 *  baseApi: environment.api.url,
 *   apiKey: (key: string) => {
 *    if(key === 'Meeco-Subscription-Key') return environment.vault.subscription_key;
 *    if(key === 'Authorization) return user.vault_access_token
 *   }
 * }).someMethod();
 * ```
 *
 * you can create a factory that returns these instances for you:
 *
 * ```ts
 * const factory = vaultAPIFactory(environment);
 * const forUser = factory(userAuth);
 * forUser.ItemsAPI.getItems();
 * forUser.ConnectionAPI.getConnections();
 * // etc...
 * ```
 */
export declare type VaultAPIFactory = (userAuth: UserAuth, headers?: IHeaders) => VaultAPIFactoryInstance;
export declare type VaultAPIFactoryInstance = {
    [key in VaultAPIName]: InstanceType<typeof Vault[key]>;
};
/**
 * Results in a factory function that can be passed user auth information and then get
 * arbitrary Keystore api instances to use.
 */
export declare const keystoreAPIFactory: (environment: Environment) => (userAuth: UserAuth, headers?: IHeaders | undefined) => KeystoreAPIFactoryInstance;
/**
 * Results in a factory function that can be passed user auth information and then get
 * arbitrary Vault api instances to use.
 */
export declare const vaultAPIFactory: (Environment: any) => (UserAuth: any, IHeaders?: any) => VaultAPIFactoryInstance;
export {};
