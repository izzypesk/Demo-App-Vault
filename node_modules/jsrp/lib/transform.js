// Generated by CoffeeScript 2.3.2
(function() {
  var BigInteger, Transform;

  BigInteger = require('jsbn').BigInteger;

  Transform = (function() {
    var TransBigInt, TransBuffer, TransPad;

    class Transform {
      cleanHex(hexStr) {
        return hexStr.split(/\s/).join('');
      }

      constructor() {
        this.bigInt = new TransBigInt;
        this.buffer = new TransBuffer;
        this.pad = new TransPad;
      }

    };

    TransBigInt = class TransBigInt {
      // Specify the toHex method in case we decide to change BigInteger 
      // libraries.
      toHex(bigIntegerObj) {
        var thisHexString;
        thisHexString = bigIntegerObj.toString(16);
        // If the length of the hex string is odd, JSBN left off a leading
        // zero.
        if (thisHexString.length % 2 === 1) {
          thisHexString = "0" + thisHexString;
        }
        return thisHexString;
      }

      fromHex(hexStr) {
        return new BigInteger(hexStr, 16);
      }

      // Convert a BigInteger to a buffer. This works by converting the
      // BigInteger to a hex string, then loading the hex string into a buffer.
      // Definitely not the best way to do it, but it works well.
      toBuffer(bigIntegerObj) {
        var thisHexString;
        thisHexString = this.toHex(bigIntegerObj);
        return Buffer.from(thisHexString, 'hex');
      }

    };

    TransBuffer = class TransBuffer {
      toHex(bufferObj) {
        return bufferObj.toString('hex');
      }

      // Convert a buffer to a BigInteger. This works the same way TransBigInt.
      // toBuffer works, by first converting to hex and then loading back.
      toBigInteger(bufferObj) {
        var thisHexString;
        thisHexString = this.toHex(bufferObj);
        return new BigInteger(thisHexString, 16);
      }

    };

    TransPad = class TransPad extends TransBigInt {
      to(n, length) {
        var padding, result;
        padding = length - n.length;
        // Check for negative padding here.
        result = Buffer.alloc(length);
        result.fill(0, 0, padding);
        n.copy(result, padding);
        return result;
      }

      toN(number, params) {
        return this.to(this.toBuffer(number), params.length / 8);
      }

      toH(number, params) {
        var hashBits;
        hashBits = null;
        switch (params.hash) {
          case 'sha1':
            hashBits = 160;
            break;
          case 'sha256':
            hashBits = 256;
            break;
          case 'sha512':
            hashBits = 512;
            break;
          default:
            throw Error('Unable to determine hash length!');
        }
        return this.to(this.toBuffer(number), hashBits / 8);
      }

    };

    return Transform;

  }).call(this);

  module.exports = new Transform;

}).call(this);
